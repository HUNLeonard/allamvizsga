<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tétel 13 - Operációs rendszerek II.</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../assets/css/tetel.css">
    <script defer data-domain="allamvizsga.netlify.app" src="https://plausible.io/js/script.js"></script>
</head>
<body class="dark-mode">
    <i class="fas fa-arrow-left back-button" id="backButton"></i>
    <i class="fas fa-adjust theme-toggle" id="themeToggle"></i>

    <h1>Operációs rendszerek II - 13. tétel</h1>
    <p class="desc"><em>
        <span class="highlight">Processzusok kommunikációja, versenyhelyzetek, kölcsönös kizárás. </span><br>
        Konkurens és kooperatív processzusok. <br>
        <span class="highlight">Kritikus szekciók és megvalósítási módszereik: kölcsönös kizárás tevékeny várakozással (megszakítások tiltása, változók zárolása, szigorú váltogatás, Peterson megoldása, TSL utasítás). </span><br>
        Altatás és ébresztés: termelő-fogyasztó probléma, szemaforok, mutex-ek, monitorok, Üzenet, adás, vétel. <br>
        <span class="highlight">Írók és olvasók problémája. </span><br>
        Sorompók.<br>
    </em></p>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>1. Processzusok kommunikációja, versenyhelyzetek, kölcsönös kizárás</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>1. Processzusok kommunikációja</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a processzusok közti kommunikáció?</span> A processzusok közti kommunikáció (IPC – InterProcess Communication) <span class="highlight">lehetővé teszi a processzusok számára az információcsere és együttműködés megvalósítását</span>. Ez alapvető fontosságú a modern operációs rendszerekben, ahol számos folyamat fut párhuzamosan és szükség van az összehangolt működésre.</p>
                
                <div class="step">
                    <p><span class="key-point">IPC fő területei:</span></p>
                    <ol>
                        <li><span class="highlight">Információküldés:</span> Hogyan tud egy processzus adatot küldeni egy másiknak?</li>
                        <li><span class="highlight">Kritikus tevékenységek szinkronizálása:</span> Hogyan biztosítható, hogy a processzusok ne zavarják egymást kritikus műveletek során?</li>
                        <li><span class="highlight">Processzusok sorrendezése:</span> Hogyan állítsuk sorrendbe a processzusokat függőségek esetén?</li>
                    </ol>
                </div>
                <p><span class="key-point">Példa:</span> Egy parancsértelmező adatcsőben az első processzus kimenete a második processzus bemenete lesz, és így tovább. Ezért <span class="highlight">szükséges a processzusok közti kommunikáció, előnyben részesítve egy megszakítások nélküli, jól strukturált módot.</span></p>
                <p><span class="key-point">Hogyan valósul meg a kommunikáció?</span> A processzusok kommunikálhatnak <span class="highlight">közös memóriaterületen keresztül</span>, amely lehet a főmemóriában vagy egy megosztott fájlban. A kommunikáció módja nem változtat a felmerülő problémák természetén.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>2. Háttérnyomtatás példa</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A háttérnyomtatás egy olyan megoldás, amely lehetővé teszi, hogy a <span class="highlight">nyomtatási feladatokat a rendszer a háttérben</span>, a felhasználói tevékenységtől függetlenül végezze el.</p>
                
                <div class="step">
                    <p><span class="key-point">Folyamat lépései:</span></p>
                    <ol>
                        <li><span class="highlight">Nyomtatási kérés:</span> Amikor a kliens (felhasználó vagy alkalmazás) nyomtatni szeretne egy dokumentumot, elindít egy nyomtatási folyamatot.</li>
                        <li><span class="highlight">Háttérkatalógus frissítése:</span> A nyomtatandó fájl neve bekerül a háttérkatalógusba</li>
                        <li><span class="highlight">Nyomtató démon:</span> Rendszeresen ellenőrzi a háttérkatalógust és elindítja a nyomtatást</li>
                        <li><span class="highlight">Nyomtatás végrehajtása:</span> A fájl kinyomtatása és eltávolítása a háttérkatalógusból</li>
                    </ol>
                </div>
                <p><span class="key-point">Háttérkatalógus:</span> A háttérkatalógus egy olyan adatstruktúra, amely sorszámmal azonosított rekeszeket tartalmaz, mindegyik rekesz egy nyomtatandó fájl nevét tárolja.</p>
                
                <p><span class="key-point">Előny:</span> A felhasználók <span class="highlight">folytathatják a munkájukat</span> anélkül, hogy megvárnák a nyomtatás befejezését.</p>
                
                <p><span class="key-point">Megjegyzés:</span> Ez a módszer nem csak nyomtatásra alkalmazható, hanem <span class="highlight">bármilyen időigényes vagy erőforrás-igényes feladatra</span>, amit a háttérben kell futtatni.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>3. Versenyhelyzetek</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a versenyhelyzet?</span> Versenyhelyzetnek nevezzük azokat az eseteket, amikor <span class="highlight">két vagy több processzus egyidejűleg próbál hozzáférni vagy módosítani megosztott adatokat</span>, és a végeredmény attól függ, hogy melyik processzus mikor és hogyan fér hozzá az adatokhoz.</p>
                
                <div class="step">
                    <p><span class="key-point">Versenyhelyzetek jellemzői:</span></p>
                    <ul>
                        <li><span class="highlight">Nem determinisztikus viselkedés:</span> Az eredmény függ a processzusok időzítésétől.</li>
                        <li><span class="highlight">Nehéz nyomon követni:</span> A hibák nem konzisztensen jelentkeznek, ami megnehezíti a hibakeresést.</li>
                        <li><span class="highlight">Potenciálisan súlyos következmények:</span> Adatvesztéshez vagy inkonzisztens állapotokhoz vezethetnek.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Hogyan kerülhetők el a versenyhelyzetek?</span> A versenyhelyzetek elkerülhetők, ha <span class="highlight">biztosítjuk, hogy két processzus soha nincs egyszerre a kritikus szekciójában</span>. Ez a kölcsönös kizárás alapelve.</p>
                <div class="step">
                    <p><span class="key-point">Megoldás versenyhelyzetekre:</span></p>
                    <ul>
                        <li>A kritikus szakaszok <span class="highlight">szinkronizálása</span> szükséges</li>
                        <li>Szinkronizációs mechanizmusok:
                            <ul>
                                <li><span class="highlight">Szemaforok:</span> Jelzik, hogy egy erőforrás szabad vagy foglalt</li>
                                <li><span class="highlight">Mutexek:</span> Egyszerű zárolási mechanizmusok <br><em>( biztosítják, hogy egyszerre csak egy folyamat férhessen hozzá egy adott erőforráshoz. )</em></li>
                                <li><span class="highlight">Monitorok:</span> Automatikus szinkronizációt kezelő programozási konstrukciók</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="algorithm">
            <h2>4. Kölcsönös kizárás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a kölcsönös kizárás?</span> A kölcsönös kizárás egy olyan mechanizmus, amely <span class="highlight">biztosítja, hogy egyszerre csak egy processzus férhessen hozzá egy megosztott erőforráshoz vagy kritikus szekcióhoz</span>. Ez kulcsfontosságú a versenyhelyzetek elkerülésében és a konzisztens adatállapotok fenntartásában.</p>
                
                <div class="step">
                    <p><span class="key-point">Kölcsönös kizárás követelményei:</span></p>
                    <ol>
                        <li><span class="highlight">Exkluzivitás:</span> Egyszerre csak egy processzus lehet a kritikus szekcióban.</li>
                        <li><span class="highlight">Haladás:</span> Ha nincs processzus a kritikus szekcióban, és van várakozó processzus, akkor valamelyiknek be kell jutnia.</li>
                        <li><span class="highlight">Korlátozott várakozás:</span> Egy processzus sem várhat végtelen ideig a kritikus szekcióba való belépésre.</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Miért fontos a kölcsönös kizárás?</span> A kölcsönös kizárás <span class="highlight">megakadályozza az adatok inkonzisztens állapotba kerülését</span>, és biztosítja a processzusok közötti biztonságos együttműködést. Ez alapvető a megbízható és kiszámítható rendszerműködés szempontjából.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>2. Konkurens és kooperatív processzusok</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>1. Konkurens processzusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mik a konkurens processzusok?</span> A konkurens processzusok olyan folyamatok, amelyek <span class="highlight">párhuzamosan futnak és versenyeznek a rendszer erőforrásaiért, különösen a CPU-időért</span>. Ezek a processzusok függetlenül működnek egymástól, és az operációs rendszer feladata a közöttük való váltás és az erőforrások elosztása.</p>
                
                <div class="step">
                    <p><span class="key-point">Konkurens processzusok jellemzői:</span></p>
                    <ul>
                        <li><span class="highlight">Párhuzamos végrehajtás:</span> Látszólag egyidejűleg futnak, valójában gyorsan váltakozva használják a CPU-t.</li>
                        <li><span class="highlight">Erőforrásokért való versengés:</span> Minden processzus igyekszik minél több CPU-időt és egyéb erőforrást megszerezni.</li>
                        <li><span class="highlight">Preemptív ütemezés:</span> Az operációs rendszer bármikor megszakíthatja és felfüggesztheti a futó processzust egy másik javára.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Miért fontosak a konkurens processzusok?</span> A konkurens processzusok lehetővé teszik a <span class="highlight">rendszer erőforrásainak hatékony kihasználását és a többfeladatos működést</span>. Ez javítja a rendszer teljesítményét és válaszképességét, különösen többmagos processzorok esetén.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>2. Kooperatív processzusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mik a kooperatív processzusok?</span> A kooperatív processzusok olyan folyamatok, amelyek <span class="highlight">együttműködnek egymással és önként adják át a vezérlést más processzusoknak</span>. Ebben a modellben a processzusok maguk döntenek arról, mikor engedik át a CPU használatát más folyamatoknak.</p>
                
                <div class="step">
                    <p><span class="key-point">Kooperatív processzusok jellemzői:</span></p>
                    <ul>
                        <li><span class="highlight">Önkéntes vezérlésátadás:</span> A processzusok saját maguk határozzák meg, mikor adják át a vezérlést.</li>
                        <li><span class="highlight">Nem preemptív ütemezés:</span> Az operációs rendszer nem szakítja meg erőszakosan a futó processzust.</li>
                        <li><span class="highlight">Kiszámíthatóbb végrehajtás:</span> A processzusok jobban kontrollálhatják a végrehajtás menetét.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Milyen kockázatai vannak a kooperatív processzusoknak?</span> A kooperatív modell <span class="highlight">kockázata, hogy egy rosszul viselkedő processzus blokkolhatja a teljes rendszert</span>, ha nem adja át a vezérlést. Ez a modell nagyobb felelősséget ró a programozókra a helyes működés biztosításában.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>3. Konkurens vs. Kooperatív processzusok összehasonlítása</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mik a fő különbségek?</span> A konkurens és kooperatív processzusok közötti fő különbségek a <span class="highlight">vezérlésátadás módjában, az ütemezésben és a rendszer stabilitásában</span> mutatkoznak meg.</p>
                
                <div class="step">
                    <p><span class="key-point">Összehasonlítás:</span></p>
                    <table>
                        <tr>
                            <th>Szempont</th>
                            <th>Konkurens Processzusok</th>
                            <th>Kooperatív Processzusok</th>
                        </tr>
                        <tr>
                            <td>Vezérlésátadás</td>
                            <td><span class="highlight">OS által kikényszerített</span></td>
                            <td><span class="highlight">Önkéntes</span></td>
                        </tr>
                        <tr>
                            <td>Ütemezés</td>
                            <td><span class="highlight">Preemptív</span></td>
                            <td><span class="highlight">Nem preemptív</span></td>
                        </tr>
                        <tr>
                            <td>Rendszer stabilitás</td>
                            <td><span class="highlight">Magasabb</span></td>
                            <td><span class="highlight">Alacsonyabb</span></td>
                        </tr>
                        <tr>
                            <td>Programozói felelősség</td>
                            <td><span class="highlight">Alacsonyabb</span></td>
                            <td><span class="highlight">Magasabb</span></td>
                        </tr>
                    </table>
                </div>
                
                <p><span class="key-point">Melyik jobb?</span> Mindkét modellnek megvan a maga <span class="highlight">előnye és hátránya</span>. A konkurens modell általában jobban alkalmazható modern, többfeladatos környezetekben, míg a kooperatív modell egyszerűbb rendszerekben vagy speciális alkalmazásokban lehet előnyös.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>3. Kritikus szekciók és megvalósítási módszereik</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>1. Kritikus szekciók</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a kritikus szekció?</span> A kritikus szekció a program azon része, ahol <span class="highlight">a processzus megosztott erőforrásokat vagy adatokat ér el vagy módosít</span>. Ez a rész különös figyelmet igényel, mert itt alakulhatnak ki versenyhelyzetek több processzus egyidejű hozzáférése esetén.</p>
                
                <div class="step">
                    <p><span class="key-point">Kritikus szekciók kezelésének feltételei:</span></p>
                    <ol>
                        <li>Ne legyen két processzus <span class="highlight">egyszerre a saját kritikus szekciójában</span></li>
                        <li>Semmilyen előfeltétel ne legyen a <span class="highlight">sebességekről vagy a CPU-k számáról</span></li>
                        <li>Egyetlen, a kritikus szekcióján kívül futó processzus sem <span class="highlight">blokkolhat más processzusokat</span></li>
                        <li>Egyetlen processzusnak se kelljen <span class="highlight">örökké arra várni</span>, hogy belépjen a kritikus szekciójába</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Miért fontosak a kritikus szekciók?</span> A kritikus szekciók megfelelő kezelése <span class="highlight">kulcsfontosságú a rendszer integritásának és stabilitásának megőrzéséhez</span>. Helyes implementációjuk biztosítja, hogy a megosztott erőforrások konzisztens állapotban maradjanak.</p>
                
                <img src="../assets/images/kritikus_szekcio.webp" alt="Kritikus szekció példa" class="graph-image">
                <p>A fenti ábra szemlélteti, hogyan lépnek be és hagyják el a processzusok a kritikus szekciót.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>1,5. Kritikus szekció vs. Kölcsönös kizárás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a különbség a kritikus szekció és a kölcsönös kizárás között?</span> Bár szorosan kapcsolódnak egymáshoz, fontos megkülönböztetni ezt a két fogalmat:</p>
                
                <div class="step">
                    <p><span class="key-point">Kritikus szekció:</span></p>
                    <ul>
                        <li>A program azon <span class="highlight">része, ahol a processzus megosztott erőforrást ér el vagy módosít</span></li>
                        <li>Egy <span class="highlight">kódrészlet</span>, amely potenciálisan versenyhelyzethez vezethet</li>
                        <li>Például: egy globális változó módosítása, fájlírás, adatbázis-művelet</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Kölcsönös kizárás:</span></p>
                    <ul>
                        <li>Egy <span class="highlight">mechanizmus vagy protokoll</span>, amely biztosítja, hogy egyszerre csak egy processzus léphessen be a kritikus szekcióba</li>
                        <li>A cél a <span class="highlight">versenyhelyzetek elkerülése</span> és az adatok konzisztenciájának megőrzése</li>
                        <li>Például: zárak, szemaforok, mutexek használata</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Összefoglalva:</span> A kritikus szekció <span class="highlight">azonosítja a problémás kódrészletet</span>, míg a kölcsönös kizárás <span class="highlight">megoldja a problémát</span> azáltal, hogy szabályozza a hozzáférést ehhez a kódrészlethez.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>2. Megszakítások tiltása - k.k. módszer</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Hogyan működik a megszakítások tiltása?</span> Ez a módszer <span class="highlight">letiltja az összes megszakítást, amíg egy processzus a kritikus szekcióban tartózkodik</span>. Ezáltal megakadályozza, hogy más processzusok megszakítsák a végrehajtást és hozzáférjenek a megosztott erőforrásokhoz.</p>
                
                <div class="step">
                    <p><span class="key-point">Lépések:</span></p>
                    <ul>
                        <li>Minden processzus <span class="highlight">letiltja az összes megszakítást</span> a kritikus szekcióba lépés után</li>
                        <li>A processzus <span class="highlight">újraengedélyezi a megszakításokat</span>, mielőtt elhagyná a kritikus szekciót</li>
                        <li>Ezáltal nem fordulhat elő <span class="highlight">óramegszakítás</span> a kritikus szekcióban.</li>
                        <li>A CPU nem vált másik processzusra a megszakítások letiltása alatt.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mik a korlátai?</span> Bár egyszerű megoldás, a megszakítások tiltása <span class="highlight">nem alkalmazható többprocesszoros rendszerekben</span>, és hosszú ideig tartó kritikus szekciók esetén jelentősen csökkentheti a rendszer válaszképességét.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>3. Változók zárolása - k.k. módszer</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a változók zárolása?</span> Ez a módszer <span class="highlight">egy vagy több változót használ a kritikus szekció foglaltságának jelzésére</span>. Ezek a változók segítenek <span class="highlight">koordinálni a folyamatokat</span> és elkerülni a versenyhelyzeteket. </p>
                
                <div class="step">
                    <p><span class="key-point">Működési elv:</span></p>
                    <ul>
                        <li>Egyetlen osztott <span class="highlight">zárolási változót</span> használ</li>
                        <li>A zárolási változó <span class="highlight">kezdeti értéke 0</span></li>
                        <li>A kritikus szekcióba lépés előtt a processzus <span class="highlight">teszteli ezt a változót</span></li>
                        <li>Ha az értéke 0, akkor <span class="highlight">1-re állítja</span>, és belép a kritikus szekciójába</li>
                        <li>Ha az értéke 1, a processzus <span class="highlight">addig várakozik</span>, amíg az értéke 0 nem lesz, majd újra próbálkozik</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mik a problémák?</span> Ez a módszer <span class="highlight">nem garantálja a kölcsönös kizárást</span>, mert versenyhelyzet alakulhat ki a változó ellenőrzése és módosítása között. Emellett <span class="highlight">tevékeny várakozást</span> eredményezhet, ami pazarolja a CPU-időt.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>4. Szigorú váltogatás - k.k. módszer</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a szigorú váltogatás?</span> A szigorú váltogatás egy olyan megoldás, ahol <span class="highlight">a processzusok felváltva léphetnek be a kritikus szekcióba</span>. Ez biztosítja a kölcsönös kizárást, de nem hatékony megoldás.</p>
                
                <div class="step">
                    <p><span class="key-point">Működési elv:</span></p>
                    <ul>
                        <li>A processzusok <span class="highlight">kizárólag egymást követik</span> a kritikus szekcióban</li>
                        <li><span class="highlight">Előny:</span> Egyszerű megvalósítás</li>
                        <li><span class="highlight">Hátrány:</span> Pazarolja a CPU időt a <span class="highlight">folyamatos teszteléssel</span></li>
                        <li>Problémás, ha a processzusok <span class="highlight">sebessége eltér</span></li>
                        <li><em>( Az egyik processzus sokáig várakozhat, míg a másik a kritikus szekcióban dolgozik. )</em></li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mik a hátrányai?</span> A szigorú váltogatás <span class="highlight">nem hatékony, ha az egyik processzus lassabb</span> vagy ritkábban igényli a kritikus szekciót. Ez szükségtelen várakozáshoz és az erőforrások pazarlásához vezethet.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>5. Peterson megoldása - k.k. módszer</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi Peterson megoldása?</span> Peterson megoldása egy <span class="highlight">szoftveres algoritmus a kölcsönös kizárás megvalósítására</span> két processzus esetén. Ez a módszer kombinálja a zászlók és a turn változó használatát.</p>
                
                <div class="step">
                    <p><span class="key-point">Az algoritmus elemei:</span></p>
                    <ul>
                        <li>Kombinálja az <span class="highlight">egymás váltogatását, zárolási változókat és figyelmeztető változókat</span></li>
                        <li>Két C eljárást használ: <code>enter_region</code> és <code>leave_region</code></li>
                        <li><span class="highlight">Előny:</span> Udvairas megoldás, ahol a processzusok <span class="highlight">maguk elé engedik egymást</span></li>
                    </ul>
                </div>
                
                <p><span class="key-point">Miért hatékony?</span> Peterson megoldása <span class="highlight">garantálja a kölcsönös kizárást és elkerüli a holtpontot</span>. Emellett <span class="highlight">fair megoldást biztosít</span>, mert mindkét processzusnak egyenlő esélyt ad a belépésre.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>6. TSL utasítás - k.k. módszer</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a TSL utasítás?</span> A TSL (Test and Set Lock) egy <span class="highlight">hardveres utasítás, amely atomikusan ellenőrzi és beállítja egy memóriacím értékét</span>. Ez az utasítás kulcsfontosságú a kölcsönös kizárás hatékony megvalósításában.</p>
                
                <div class="step">
                    <p><span class="key-point">TSL működése:</span></p>
                    <ul>
                        <li>A Test and Set Lock (TSL) utasítás <span class="highlight">hardveres segítséggel</span> működik</li>
                        <li>Beolvassa a LOCK memória szót az RX regiszterbe, és <span class="highlight">nem nulla értéket ír</span> a memória címre egyetlen oszthatatlan művelettel</li>
                        <li>A művelet végrehajtása során a CPU <span class="highlight">zárolja a memóriasínt</span></li>
                        <li><span class="highlight">Előny:</span> Hatékony megoldás <span class="highlight">többprocesszoros rendszerekben</span></li>
                        <li><span class="highlight">Hátrány:</span> Szigorú betartást igényel a <span class="highlight">kölcsönös kizárás biztosításához</span></li>
                    </ul>
                </div>
                
                <p><span class="key-point">Miért előnyös?</span> A TSL utasítás <span class="highlight">hatékony és biztonságos megoldást nyújt</span> a kölcsönös kizárásra, különösen többprocesszoros rendszerekben. Kiküszöböli a szoftveres megoldások versenyhelyzeteit.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>4. Altatás és ébresztés: termelő-fogyasztó probléma, szemaforok, mutex-ek, monitorok, Üzenet, adás, vétel</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>1. Szemaforok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a szemafor és mire használjuk?</span> A szemafor egy <span class="highlight">speciális változótípus</span>, amely lehetővé teszi az <span class="highlight">ébresztések számolását és tárolását</span> későbbi felhasználás céljából. Ez egy <span class="highlight">kulcsfontosságú eszköz</span> a párhuzamos programozásban és a folyamatok szinkronizálásában. A szemafor értéke lehet <span class="highlight">0</span>, jelezve, hogy nincs elmentett ébresztés, vagy bármilyen <span class="highlight">pozitív egész szám</span>, amely a függőben lévő ébresztések számát jelzi.</p>

                <div class="step">
                    <p><span class="key-point">Szemafor műveletek:</span></p>
                    <ul>
                        <li><span class="highlight">Down (Altató) művelet:</span>
                            <ul>
                                <li>Megvizsgálja, hogy a szemafor értéke <span class="highlight">nagyobb-e, mint 0</span>.</li>
                                <li>Ha igen, <span class="highlight">csökkenti az értékét</span> (felhasznál egy tárolt ébresztést), és azonnal folytatja a végrehajtást.</li>
                                <li>Ha az érték 0, akkor a processzust <span class="highlight">elaltatja</span>, mielőtt a down befejeződne.</li>
                                <li>Ez egy <span class="highlight">oszthatatlan (atomi) művelet</span>, ami kritikus a versenyhelyzetek elkerüléséhez.</li>
                            </ul>
                        </li>
                        <li><span class="highlight">Up (Ébresztő) művelet:</span>
                            <ul>
                                <li><span class="highlight">Növeli</span> a szemafor értékét.</li>
                                <li>Ha vannak alvó processzusok a szemaforon, <span class="highlight">egyet felébreszt</span> közülük.</li>
                                <li>Az up műveletet végrehajtó processzus <span class="highlight">nem blokkolható</span>.</li>
                                <li>Ez a művelet is <span class="highlight">oszthatatlan</span>, biztosítva a konzisztenciát.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mire használhatók a szemaforok?</span> Szemaforokat használhatunk <span class="highlight">kölcsönös kizárás megvalósítására, erőforrások számlálására és processzusok szinkronizálására</span>. Különösen hasznosak komplex szinkronizációs problémák, mint például a termelő-fogyasztó probléma megoldásában.</p>
                <p><span class="key-point">Hogyan valósítják meg a szemaforokat?</span> A szemafor műveleteket általában <span class="highlight">rendszerhívásként implementálják</span>. Az operációs rendszer ideiglenesen <span class="highlight">letiltja a megszakításokat</span>, amíg vizsgálja és frissíti a szemafor értékét, valamint szükség esetén altatja a processzust. Többprocesszoros rendszerekben minden szemafort <span class="highlight">védeni kell egy zárolási változóval</span>, általában a <span class="highlight">TSL (Test and Set Lock)</span> utasítást használva, hogy egyszerre csak egy CPU vizsgálhassa a szemafort.</p>
            </div>
        </div>
        
        <div class="algorithm">
            <h2>1,5. Termelő-fogyasztó probléma</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a termelő-fogyasztó probléma?</span> A termelő-fogyasztó probléma egy <span class="highlight">klasszikus szinkronizációs kihívás</span> az operációs rendszerekben. Két processzus osztozik egy <span class="highlight">közös, rögzített méretű tárolón</span>. Az egyik, a <span class="highlight">termelő</span>, adatokat helyez el benne, míg a másik, a <span class="highlight">fogyasztó</span>, kiveszi azokat.</p>
                
                <div class="step">
                    <p><span class="key-point">Mikor jelentkeznek nehézségek?</span></p>
                    <ul>
                        <li>Ha a termelő új elemet kíván a tárolóba tenni, de az már <span class="highlight">tele van</span>. Ilyenkor nem tud tovább termelni, de várakoznia kell.</li>
                        <li>Ha a fogyasztó elemet akar kivenni, de a tároló <span class="highlight">üres</span>. Ebben az esetben nincs mit fogyasztania, tehát várakozásra kényszerül.</li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">A probléma elemei:</span></p>
                    <ul>
                        <li><span class="highlight">Termelők:</span> Adatokat állítanak elő</li>
                        <li><span class="highlight">Fogyasztók:</span> Feldolgozzák a termelt adatokat</li>
                        <li><span class="highlight">Puffer:</span> Korlátozott méretű tárhely az adatok átmeneti tárolására</li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">Hogyan oldjuk meg ezt a problémát?</span></p>
                    <ul>
                        <li>A termelő <span class="highlight">elalszik</span>, ha a tároló tele van. Ezzel <span class="highlight">nem pazarolja a CPU erőforrásait</span> felesleges ellenőrzésekre.</li>
                        <li>A fogyasztó <span class="highlight">felébreszti</span> a termelőt, ha kivett egy elemet. Így a termelő tudni fogja, hogy <span class="highlight">újra van hely</span> a tárolóban.</li>
                        <li>A fogyasztó <span class="highlight">elalszik</span>, ha a tároló üres. Ez megakadályozza a <span class="highlight">folyamatos, felesleges ellenőrzéseket</span>.</li>
                        <li>A termelő <span class="highlight">felébreszti</span> a fogyasztót, ha új elemet tett a tárolóba. Ezáltal a fogyasztó <span class="highlight">azonnal tudni fog</span> az új elemről.</li>
                    </ul>
                    <p>Ez a megoldás <span class="highlight">hatékonyan kezeli a szinkronizációt</span>, minimalizálja a felesleges CPU-használatot, és biztosítja a <span class="highlight">folyamatos, zökkenőmentes működést</span> a termelő és fogyasztó között.</p>
                </div>
            </div>
        </div>

        <div class="algorithm">
            <h2>2. Mutex-ek</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mik a mutex-ek?</span> A mutex (kölcsönös kizárás) egy <span class="highlight">egyszerű zárolási mechanizmus</span>, amely biztosítja, hogy egyszerre csak egy processzus vagy szál férhessen hozzá egy megosztott erőforráshoz. Lényegében egy <span class="highlight">bináris szemafor</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Mutex műveletek:</span></p>
                    <ul>
                        <ul>
                            <li><span class="highlight">mutex_lock eljárás:</span> Amikor egy processzus hozzá akar férni a kritikus szekcióhoz, meghívja ezt.
                                <ul>
                                    <li>Ha a mutex <span class="highlight">nem zárolt</span>, a hívás sikeres, és a processzus beléphet a kritikus szekcióba.</li>
                                    <li>Ha <span class="highlight">zárolt</span>, a hívó processzus blokkolódik, amíg a mutex fel nem szabadul.</li>
                                </ul>
                            </li>
                            <li><span class="highlight">mutex_unlock eljárás:</span> A kritikus szekcióból kilépve hívják meg.
                                <ul>
                                    <li><span class="highlight">Feloldja</span> a mutexet.</li>
                                    <li>Ha több processzus is várakozik, közülük az egyik <span class="highlight">véletlenszerűen kiválasztott</span> megszerezheti a zárolást.</li>
                                </ul>
                            </li>
                        </ul>
                    </ul>
                </div>
                
                <p><span class="key-point">Miben különböznek a szemaforoktól?</span> A mutex-ek <span class="highlight">egyszerűbbek és specifikusabbak, mint a szemaforok</span>. Kizárólag kölcsönös kizárásra használatosak, míg a szemaforok többféle szinkronizációs feladatra alkalmazhatók.</p>
                <p><span class="key-point">Milyen veszélyeket rejt a mutexek használata?</span> A fő veszély a <span class="highlight">holtpont (deadlock)</span> kialakulása. Ez olyan helyzet, amikor <span class="highlight">minden érintett processzus blokkolódik</span>, mert mindegyik olyan erőforrásra vár, amit egy másik, szintén blokkolt processzus tart foglalva. A mutexek <span class="highlight">helyes használata</span> és a erőforrások <span class="highlight">megfelelő sorrendben történő lefoglalása</span> kulcsfontosságú a holtpontok elkerüléséhez.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>3. Monitorok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi az a monitor és mire szolgál?</span> A monitor egy <span class="highlight">magasabb szintű szinkronizációs eszköz</span>, amely eljárások, változók és adatszerkezetek együttese, egy <span class="highlight">speciális modulba vagy csomagba összegyűjtve</span>. A monitorok célja, hogy <span class="highlight">strukturált és biztonságos módot</span> nyújtsanak a párhuzamos programozáshoz, <span class="highlight">automatikusan kezelve</span> a kölcsönös kizárást.</p>
                <div class="step">
                    <p><span class="key-point">Monitor jellemzői:</span></p>
                    <ul>
                        <li><span class="highlight">Kölcsönös kizárás:</span> Automatikusan biztosítja, hogy egyszerre csak egy processzus lehessen a monitorban</li>
                        <li><span class="highlight">Feltételes változók:</span> Lehetővé teszik a processzusok altatását és ébresztését</li>
                        <li><span class="highlight">Adatrejtés:</span> A monitor adatai csak a monitor eljárásain keresztül érhetők el</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Miért előnyösek a monitorok?</span> A monitorok <span class="highlight">magasabb szintű absztrakciót biztosítanak</span> a szinkronizációhoz, ami csökkenti a programozási hibák lehetőségét és növeli a kód olvashatóságát. Különösen hasznosak komplex szinkronizációs problémák megoldásában.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>4. Üzenet, adás, vétel</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi az üzenetküldés?</span> Az üzenetküldés egy <span class="highlight">kommunikációs mechanizmus a processzusok között</span>, ahol az egyik processzus üzenetet küld, a másik pedig fogadja azt. Ez lehetővé teszi a processzusok közötti információcserét és szinkronizációt.</p>
                
                <div class="step">
                    <p><span class="key-point">Üzenetküldési műveletek:</span></p>
                    <ul>
                        <li><span class="highlight">Send (Küldés):</span> Egy processzus üzenetet küld egy másiknak</li>
                        <li><span class="highlight">Receive (Fogadás):</span> Egy processzus fogadja a neki küldött üzenetet</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Milyen típusú üzenetküldés létezik?</span> Az üzenetküldés lehet <span class="highlight">szinkron</span> (a küldő vár, amíg a fogadó átveszi az üzenetet) vagy <span class="highlight">aszinkron</span> (a küldő folytatja a működését az üzenet elküldése után). Mindkét módszernek megvannak a maga előnyei és használati esetei.</p>
                
                <p><span class="key-point">Miért hasznos az üzenetküldés?</span> Az üzenetküldés <span class="highlight">rugalmas módot biztosít a processzusok közötti kommunikációra és szinkronizációra</span>, különösen elosztott rendszerekben. Lehetővé teszi a laza csatolást a processzusok között, ami elősegíti a moduláris és skálázható rendszertervezést.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>5. Írók és olvasók problémája</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>1. Az írók és olvasók probléma</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi az írók és olvasók probléma?</span> Az írók és olvasók probléma egy <span class="highlight">klasszikus szinkronizációs feladat</span>, amely egy olyan helyzettel foglalkozik, ahol több processzus (írók és olvasók) osztozik egy közös erőforráson, például egy adatbázison vagy fájlon.</p>
                
                <div class="step">
                    <p><span class="key-point">A probléma lényege:</span></p>
                    <ul>
                        <li><span class="highlight">Olvasók:</span> Egyidejűleg több olvasó is hozzáférhet az adatokhoz</li>
                        <li><span class="highlight">Írók:</span> Egy író kizárólagos hozzáférést igényel az adatokhoz</li>
                        <li><span class="highlight">Konfliktus:</span> Az írók és olvasók nem férhetnek hozzá egyszerre az adatokhoz</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Milyen kihívásokat kell kezelni?</span> A fő kihívás a <span class="highlight">megfelelő egyensúly megtalálása</span> az olvasók párhuzamos hozzáférése és az írók kizárólagos hozzáférése között, miközben el kell kerülni az éhezést (starvation) is.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>2. Megoldási stratégiák</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Milyen megoldási stratégiák léteznek?</span> Több stratégia is létezik az írók és olvasók probléma kezelésére, mindegyiknek megvannak a maga előnyei és hátrányai.</p>
                
                <p><span class="key-point">Fő stratégiák:</span></p>
                <div class="step">
                    <p><span class="key-point">1. Olvasók prioritása:</span></p>
                    <ul>
                        <li>Az olvasók <span class="highlight">bármikor beléphetnek</span>, ha nincs író az adatbázisban</li>
                        <li>Az írók csak akkor léphetnek be, ha <span class="highlight">nincsenek aktív olvasók</span></li>
                        <li><span class="highlight">Előny:</span> Maximalizálja az olvasási párhuzamosságot</li>
                        <li><span class="highlight">Hátrány:</span> Az írók éhezhetnek</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">2. Írók prioritása:</span></p>
                    <ul>
                        <li>Ha egy író be akar lépni, <span class="highlight">új olvasók nem léphetnek be</span></li>
                        <li>Az író megvárja az aktív olvasók befejezését, de <span class="highlight">blokkolja az új olvasókat</span></li>
                        <li><span class="highlight">Előny:</span> Garantálja az írók hozzáférését</li>
                        <li><span class="highlight">Hátrány:</span> Az olvasók éhezhetnek</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">3. Kiegyensúlyozott megközelítés:</span></p>
                    <ul>
                        <li>Az olvasók és az írók is <span class="highlight">sorban állnak</span> (azonos prioritás)</li>
                        <li><span class="highlight">Váltakozva</span> kerülnek be az adatbázisba</li>
                        <li>Az olvasók és írók <span class="highlight">váltakozva kerülhetnek be</span> az adatbázisba</li>
                        <li><span class="highlight">Előny:</span> Egyik csoport sem szenved éhségtől</li>
                        <li><span class="highlight">Hátrány:</span> Csökkentheti a párhuzamosságot az olvasók között</li>
                    </ul>
                    
                </div>
                
                <p><span class="key-point">Melyik stratégiát válasszuk?</span> A választás függ az <span class="highlight">alkalmazás specifikus követelményeitől</span>. Ha az olvasási műveletek dominálnak, az olvasók prioritása lehet előnyös. Ha az adatok frissessége kritikus, az írók prioritása lehet jobb. Komplex rendszerekben gyakran az igazságos megoldás a legmegfelelőbb.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>6. Sorompók</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>1. Sorompók alapjai</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mik a sorompók?</span> A sorompók (barriers) olyan <span class="highlight">szinkronizációs mechanizmusok</span>, amelyek lehetővé teszik, hogy egy csoport processzus vagy szál egy meghatározott ponton bevárja egymást, mielőtt tovább haladna.</p>
                
                <div class="step">
                    <p><span class="key-point">Sorompók jellemzői:</span></p>
                    <ul>
                        <li><span class="highlight">Várakozási pont:</span> Minden processzus megáll a sorompónál</li>
                        <li><span class="highlight">Együttes továbbhaladás:</span> Csak akkor folytatódik a végrehajtás, ha minden processzus elérte a sorompót</li>
                        <li><span class="highlight">Újrahasználhatóság:</span> A sorompók általában többször is használhatók egy program futása során</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mire használjuk a sorompókat?</span> A sorompók különösen hasznosak olyan helyzetekben, ahol <span class="highlight">több processzusnak szinkronban kell működnie</span>, például párhuzamos számítások egyes fázisai között vagy elosztott rendszerekben az állapotok szinkronizálására.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>2. Sorompók működése</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Hogyan működnek a sorompók?</span> A sorompók működése általában a következő lépésekből áll:</p>
                
                <div class="step">
                    <p><span class="key-point">Működési folyamat:</span></p>
                    <ol>
                        <li><span class="highlight">Érkezés:</span> Minden processzus jelzi érkezését a sorompóhoz</li>
                        <li><span class="highlight">Várakozás:</span> A processzusok várakoznak, amíg mindenki meg nem érkezik</li>
                        <li><span class="highlight">Feloldás:</span> Az utolsó processzus érkezésekor a sorompó feloldódik</li>
                        <li><span class="highlight">Továbbhaladás:</span> Minden processzus egyszerre folytatja a végrehajtást</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Milyen implementációk léteznek?</span> A sorompók megvalósíthatók <span class="highlight">szemaforokkal, monitorokkal vagy speciális hardveres utasításokkal</span>. A választás függ a rendelkezésre álló eszközöktől és a teljesítménykövetelményektől.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>3. Sorompók alkalmazása</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mikor érdemes sorompókat használni?</span> Sorompókat számos helyzetben alkalmazhatunk, ahol <span class="highlight">szükség van a processzusok vagy szálak szinkronizálására</span> egy meghatározott ponton.</p>
                
                <div class="step">
                    <p><span class="key-point">Tipikus alkalmazási területek:</span></p>
                    <ul>
                        <li><span class="highlight">Párhuzamos számítások:</span> Mátrix műveletek, numerikus szimulációk fázisai között</li>
                        <li><span class="highlight">Elosztott rendszerek:</span> Konzisztens állapot biztosítása több csomópont között</li>
                        <li><span class="highlight">Iteratív algoritmusok:</span> Minden iteráció végén a részeredmények szinkronizálása</li>
                        <li><span class="highlight">Erőforrás-inicializálás:</span> Komplex rendszerek indításakor az összes komponens inicializálásának bevárása</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Milyen előnyökkel jár a sorompók használata?</span> A sorompók <span class="highlight">egyszerűsítik a párhuzamos programozást</span>, segítenek elkerülni a versenyhelyzeteket, és biztosítják a konzisztens állapotot a párhuzamos végrehajtás során.</p>
            </div>
        </div>


    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>Összefoglalás</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Processzusok kommunikációja, versenyhelyzetek, kölcsönös kizárás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li><span class="highlight">Processzusok kommunikációja (IPC):</span> Az információ megosztása a processzusok között.</li>
                    <li><span class="highlight">Versenyhelyzetek:</span> Két vagy több processzus megosztott adatokat olvas vagy ír, és az eredmény függ az időzítéstől.</li>
                    <li><span class="highlight">Kölcsönös kizárás:</span> Biztosítja, hogy egy időben csak egy processzus férhessen hozzá a kritikus szekcióhoz, megakadályozva a versenyhelyzeteket.</li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Konkurens és kooperatív processzusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li><span class="highlight">Konkurens processzusok:</span> Versenyeznek a CPU használatáért.</li>
                    <li><span class="highlight">Kooperatív processzusok:</span> Időnként önként lemondanak a CPU használatáról, hogy más processzusok is futtathatók legyenek.</li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Kritikus szekciók és megvalósítási módszereik</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Kritikus szekció:</span> A program azon része, amely megosztott memóriát használ.</p>
                <p><span class="key-point">Megvalósítási módszerek:</span></p>
                <ul>
                    <li><span class="highlight">Megszakítások tiltása:</span> A kritikus szekcióban a megszakítások tiltása biztosítja a kölcsönös kizárást.</li>
                    <li><span class="highlight">Változók zárolása:</span> Speciális változók használata a kritikus szekciók védelmére.</li>
                    <li><span class="highlight">Szigorú váltogatás:</span> Garantálja, hogy két processzus felváltva lép be a kritikus szekcióba.</li>
                    <li><span class="highlight">Peterson megoldása:</span> Egy algoritmus, amely biztosítja a kölcsönös kizárást két processzus között.</li>
                    <li><span class="highlight">TSL utasítás:</span> Egy speciális gépi utasítás, amely megakadályozza a versenyhelyzeteket a kritikus szekciókban.</li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Altatás és ébresztés</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Termelő-fogyasztó probléma:</span> A gyártó adatokat helyez el egy közös tárolóban, a fogyasztó pedig kiveszi azokat.</p>
                <p><span class="key-point">Szemaforok:</span> Változótípusok, amelyek számlálják az ébresztéseket.</p>
                <ul>
                    <li><span class="highlight">Down (Altató):</span> Csökkenti a szemafor értékét, és elaltatja a processzust, ha az érték 0.</li>
                    <li><span class="highlight">Up (Ébresztő):</span> Növeli a szemafor értékét, és felébreszt egy elaltatott processzust.</li>
                </ul>
                <p><span class="key-point">Mutexek (Bináris szemaforok):</span> Egyszerűsített szemaforok, amelyek csak kölcsönös kizárást kezelnek.</p>
                <p><span class="key-point">Monitorok:</span> Adatszerkezetek és változók együttese, amelyek kölcsönös kizárást biztosítanak a monitor eljárásokban.</p>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Írók és olvasók problémája</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Írók és olvasók problémája:</span> Az adatbázishoz több olvasó hozzáférhet egyszerre, de író hozzáféréskor kizár minden olvasót és más írót is.</p>
                <p><span class="key-point">Megoldás:</span> Prioritásokat adhatunk az íróknak vagy az olvasóknak, hogy elkerüljük a blokkolásokat.</p>
                <ul>
                    <li><span class="highlight">Olvasók prioritása</span></li>
                    <li><span class="highlight">Írók prioritása</span></li>
                    <li><span class="highlight">Kiegyensúlyozott megközelítés</span></li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Sorompók</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Sorompók:</span> Szinkronizációs primitívek, amelyek biztosítják, hogy egyetlen processzus sem léphet tovább, amíg az összes processzus készen nem áll egy adott fázisban.</p>
                <p><span class="key-point">Használat:</span> Pl. Nagy mátrixokon végzett párhuzamos műveleteknél hasznosak, ahol minden processzusnak be kell fejeznie a saját munkáját, mielőtt tovább léphetne a következő fázisra.</p>
            </div>
        </div>
    </div>

    <script src="../assets/js/tetel.js"></script>
</body>
</html>