<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tétel 9 - Mesterséges Intelligencia II.</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../assets/css/tetel.css">
    <script defer data-domain="allamvizsga.netlify.app" src="https://plausible.io/js/script.js"></script>
</head>
<body class="dark-mode">
    <i class="fas fa-arrow-left back-button" id="backButton"></i>
    <i class="fas fa-adjust theme-toggle" id="themeToggle"></i>

    <h1>Mesterséges Intelligencia II - 9. tétel</h1>

    <p><em><span class="highlight">Teljes együttes eloszlás tömör reprezentációja,<br> Bayes hálók</span><br>
        <span class="highlight">Gépi tanulás:</span> felügyelt tanulás problémája, döntési fák, naiv Bayes módszer, modellillesztés, mesterséges neuronhálók, k-legközelebbi szomszéd módszere. </em></p>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>1. Teljes együttes eloszlás tömör reprezentációja</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Teljes együttes eloszlás Alapfogalmak</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A teljes együttes eloszlás tömör reprezentációja az <span class="highlight">összes lehetséges eseményt és ezek valószínűségét</span> tartalmazza, amelyből kiszámítható bármely kijelentés valószínűsége (tehát feltételes valószínűsége is).</p>
            
                <div class="step">
                    <p><span class="key-point">Miért nem alkalmas a logika a hiányos tudás kezelésére?</span>Az igaz/hamis világgal és logikai következtetésekkel problémák vannak:</p>
                    <ul>
                        <li>Ha <span class="highlight">nem teljes a tudás</span> (tények vagy szabályok), akkor nem mindig tudunk logikai levezetéseket gyártani fontos kérdésekhez, döntésképtelenek leszünk</li>
                        <li>Ha <span class="highlight">heurisztikus szabályokat</span> vezetünk be, akkor a tapasztalat inkonzisztens lehet az elmélettel, tehát a logikai levezetés megint csak nem működik</li>
                    </ul>
                    <p>Következtetés: A <span class="highlight">hiányos, részleges tudás kezelésére a logika nem optimális</span></p>
                </div>
                
                
                <p><span class="key-point">Hogyan reprezentáljuk a teljes együttes eloszlást?</span> Általában <span class="highlight">táblázatos formában</span>, ahol minden lehetséges eseménykombinációhoz hozzárendeljük a valószínűségét.</p>
                <p><em>(Ahol az események listája van, és minden esemény mellett szerepel a hozzá tartozó valószínűség.)</em></p>
                <img src="../assets/images/te_eloszla_tomor_rep.webp" alt="# Teljes együttes eloszlás tömör reprezentációja" class="graph-image">
                <div class="step">
                    <p><span class="key-point">Előnyök:</span></p>
                    <ul>
                        <li>Lehetővé teszi <span class="highlight">bármely kijelentés valószínűségének kiszámítását</span></li>
                        <li>Alkalmas <span class="highlight">feltételes valószínűségek</span> meghatározására is</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Kihívás:</span> A teljes együttes eloszlás táblázat mérete <span class="highlight">exponenciálisan nő</span> a változók számával (2^n méretű n logikai változó esetén).</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Véletlen változók</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a véletlen változó?</span> Egy véletlen változónak van <span class="highlight">neve és lehetséges értékei</span> (értékkészlet, domain).</p>
                
                <div class="step">
                    <p><span class="key-point">Milyen típusú véletlen változók vannak?</span></p>
                    <ul>
                        <li><span class="highlight">Logikai:</span> Domain {igaz, hamis}, pl. Fogfájás=igaz</li>
                        <li><span class="highlight">Diszkrét:</span> Megszámlálható domain, pl. Idő={nap, eső, felhő, hó}</li>
                        <li><span class="highlight">Folytonos:</span> Valós számok tartománya, pl. <code>X < 3.2</code> egy elemi kijelentés.</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Mi az elemi esemény?</span></p>
                    <ul>
                        <li>Minden véletlen változóhoz <span class="highlight">értéket rendel</span> a hozzá tartozó domainből</li>
                        <li>Az elemi események halmaza az összes domain <span class="highlight">direkt szorzata</span></li>
                        <li>Például, ha két logikai véletlen változónk van (Luk és Fogfájás), az négy elemi eseményt ad:
                            <ul>
                                <li>luk ∧ fogfájás</li>
                                <li>luk ∧ ¬fogfájás</li>
                                <li>¬luk ∧ fogfájás</li>
                                <li>¬luk ∧ ¬fogfájás</li>
                            </ul>
                    </ul>
                </div>
                
                <p><span class="key-point">Hogyan képezhetünk komplex kijelentéseket?</span><span class="highlight"> Logikai operátorokkal</span> (∧, ∨, ¬). A valószínűség egy függvény, amely minden kijelentéshez egy valós számot rendel.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Valószínűségi alapok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a valószínűség szerepe?</span> A valószínűség a <span class="highlight">tudás tökéletlenségének kezelésére</span> szolgál, figyelembe véve az ismeretlen tényeket és szabályokat.</p>
                
                <div class="step">
                    <p><span class="key-point">Fontos fogalmak:</span></p>
                    <ul>
                        <li><span class="highlight">Feltételes valószínűség:</span> P(a|b) - az a esemény valószínűsége, ha b-t tudjuk</li>
                        <li><span class="highlight">Szorzatszabály:</span> P(a ∧ b) = P(a|b)P(b) = P(b|a)P(a)</li>
                    </ul>
                </div>
                <div class="step">
                    <p><span class="key-point">A szorzatszabály magyarázata:</span></p>
                    <ul>
                        <li><span class="highlight">P(a ∧ b):</span> az a és b események együttes bekövetkezésének valószínűsége</li>
                        <li><span class="highlight">P(a|b)P(b):</span> a valószínűsége annak, hogy <span class="highlight">b bekövetkezik</span>, és aztán <span class="highlight">a bekövetkezik</span>, feltéve hogy <span class="highlight">b már bekövetkezett</span></li>
                        <li><span class="highlight">P(b|a)P(a):</span> a valószínűsége annak, hogy <span class="highlight">a bekövetkezik</span>, és aztán <span class="highlight">b bekövetkezik</span>, feltéve hogy <span class="highlight">a már bekövetkezett</span></li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Példa:</span></p>
                    <ul>
                        <li><span class="highlight">P(luk|fogfájás)</span> = 0.8 - a lyukas fog valószínűsége, ha fáj a fog</li>
                        <li><span class="highlight">Definíció szerint:</span> P(a|b) = P(a ∧ b) / P(b), ahol P(b) > 0</li>
                    </ul>
                </div>
                <div class="step">
                    <p><span class="key-point">Valószínűségi megközelítés előnyei:</span></p>
                    <ul>
                        <li>Kezelni tudja a <span class="highlight">tudás tökéletlenségét</span> (ismeretlen tények és szabályok)</li>
                        <li>Lehetővé teszi a <span class="highlight">részleges és bizonytalan információk</span> felhasználását</li>
                        <li>Alkalmas a <span class="highlight">tapasztalatok alapján változó valószínűségek</span> kezelésére</li>
                    </ul>
                </div>
                
            </div>
        </div>

        <div class="algorithm">
            <h2>Teljes együttes eloszlás - Példa</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <div class="step">
                    <p><span class="key-point">Példa:</span> Véletlen változók: Luk, Fogfájás, Beakad (mind logikai {0, 1} típusú)</p>
                    <img src="../assets/images/te_eloszla_tomor_rep.webp" alt="# Teljes együttes eloszlás tömör reprezentációja" class="graph-image">
                    <p>P(luk ∨ fogfájás) = 0.108 + 0.012 + 0.072 + 0.008 + 0.016 + 0.064</p>
                </div>
                
                <p><span class="key-point">Megjegyzés:</span> Ha minden változó logikai, és n db változó van, akkor a táblázat 2^n méretű, ami nem skálázódik jól.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Függetlenség</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a függetlenség?</span> Az a és b kijelentések függetlenek akkor és csak akkor, ha <span class="highlight">P(a ∧ b) = P(a)P(b)</span>. Az A és B véletlen változók függetlenek, ha P(A,B) = P(A)P(B), vagy ekvivalensen P(A|B) = P(A) és P(A|B) = P(B).</p>
                
                <p><span class="key-point">Mit jelent a függetlenség?</span> Függetlenség azt jelenti, hogy a két változó akkor független, ha <span class="highlight">az egyik nem tartalmaz információt a másikról</span> <em>(az egyik nem befolyásolja a másikat).</em></p>

                <p><span class="key-point">Például:</span> ha dobok egy <span class="highlight">érmét</span> és egy <span class="highlight">kockát</span>, az érme eredménye <span class="highlight">független</span> a kocka eredményétől. Az, hogy fejet dobok az érmével, <span class="highlight">nem befolyásolja</span>, hogy milyen számot dobok a kockával.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Feltételes függetlenség</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a feltételes függetlenség?</span> Az a és b kijelentések feltételesen függetlenek c feltevésével akkor és csak akkor, ha <span class="highlight">P(a ∧ b|c) = P(a|c)P(b|c)</span>. Ekkor a és b nem feltétlenül független.</p>
                <p><span class="key-point">Quick summary:</span> Ha az együttes valószínűségük (mindkettő bekövetkezik c mellett) megegyezik a külön-külön vett valószínűségeik szorzatával</p>
                
                <div class="step">
                    <p><span class="key-point">Példa:</span></p>
                    <ul>
                        <li>A fogfájás (a) és a fogak beakadása (b) nem függetlenek, de ha tudjuk, hogy van egy lyuk (c), akkor azok lesznek.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Lényeg:</span> Feltételes függetlenség akkor áll fenn, ha két esemény függetlenné válik egy harmadik esemény bekövetkezése esetén.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Az eloszlás reprezentációjának tömörítése</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Alapelv:</span> A valószínűségi eloszlást egyszerűbben is felírhatjuk, ha feltételezzük, hogy bizonyos események függetlenek egymástól feltételesen.</p>
        
                <div class="step">
                    <p><span class="key-point">Példa:</span></p>
                    <ul>
                        <li><code>P(A, B, C) = P(A, B|C)P(C)</code></li>
                        <li>Ez tovább bontható: <code>P(A|C)P(B|C)P(C)</code></li>
                        <li>Ez <span class="highlight">feltételezi</span>, hogy A és B <span class="highlight">függetlenek egymástól</span>, ha tudjuk, hogy <span class="highlight">C történt</span>.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Lényeg:</span> Ez a módszer segít egyszerűsíteni a számításokat, ha feltételezhető, hogy bizonyos események feltételesen függetlenek.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>2. Bayes hálók + Naiv Bayes módszer</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Bayes hálók alapjai</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A Bayes hálók <span class="highlight">valószínűségi modellek leírására</span> használt eszközök, amelyek kihasználják a változók közötti feltételes függetlenségeket.</p>
                
                <div class="step">
                    <p><span class="key-point">Fő jellemzők:</span> A Bayes háló egy olyan <span class="highlight">irányított, körmentes gráf</span>, ahol:</p>
                    <ul>
                        <li>A háló csomópontok <span class="highlight">valószínűségi változókat</span> reprezentálnak</li>
                        <li>Az irányított élek <span class="highlight">ok-okozati függőségeket</span> jelölnek: ha X-ből vezet Y-ba él, akkor X függ Y-tól</li>
                        <li>Minden Xi csomóponthoz tartozik egy <span class="highlight">P(Xi | Szülők(Xi)) feltételes valószínűség eloszlás</span>, ami számszerűen megadja a szülők hatását a csomóponti változóra</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Előnyök:</span></p>
                    <ul>
                        <li><span class="highlight">Tömör reprezentáció tesznek lehetővé,</span> kihasználva a feltételes függetlenségeket</li>
                        <li><span class="highlight">Intuitív ábrázolás:</span> Könnyen értelmezhető grafikus formában</li>
                        <li><span class="highlight">Hatékony következtetés:</span> Lehetővé teszi komplex valószínűségi lekérdezések gyors megválaszolását</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Alkalmazás:</span> Bayes hálók széles körben használatosak <span class="highlight">bizonytalanság modellezésére</span> különböző területeken, például orvosi diagnosztikában, időjárás-előrejelzésben és pénzügyi kockázatelemzésben.</p>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Naiv Bayes algoritmus</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A naiv Bayes algoritmus egy <span class="highlight">egyszerű, de hatékony valószínűségi osztályozási módszer</span>, amely a Bayes-tételen alapul. A Naiv Bayes egy <span class="highlight">statisztikai következtetési módszer</span></p>
                
                <div class="step">
                    <p><span class="key-point">Működési elv:</span></p>
                    <ul>
                        <li><span class="highlight">Feltételezi</span>, hogy a bemeneti változók <span class="highlight">függetlenek egymástól</span> az osztálycímke ismeretében</li>
                        <li> módszer kiszámítja a <span class="highlight">P(osztály|attribútumok)</span> feltételes valószínűséget minden osztályra, és azt az osztályt választja, amelyikre ez a valószínűség a legnagyobb</li>
                        <li><em>(Az osztályozás a <span class="highlight">P(A|b1, ..., bn)</span> feltételes valószínűség maximalizálásával történik.)</em></li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Képlet:</span></p>
                    <p><pre style="font-size:x-large">P(A|b<sub>1</sub>, ..., bn) ≈ α P(A) <ruby>Π<rt>n</rt><rp>n</rp></ruby><sub>i=1</sub> P(b<sub>i</sub> | A)</pre></p>
                    <ul>
                        <li><span class="highlight">α</span>: normalizáló konstans</li>
                        <li><span class="highlight">P(A)</span>: prior valószínűség</li>
                        <li><span class="highlight">P(bi|A)</span>: feltételes valószínűségek</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mire használható a naiv Bayes?</span> A naiv Bayes különösen hatékony <span class="highlight">szövegfeldolgozási feladatokban</span>, például spam szűrésben vagy dokumentum kategorizálásban.</p>
                
                <p><span class="key-point">Előny:</span> A naiv Bayes algoritmus <span class="highlight">egyszerű, gyors és meglepően hatékony</span> számos valós alkalmazásban, különösen amikor korlátozott mennyiségű tanító adat áll rendelkezésre.</p>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Bayes vs Naiv Bayes</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a "naiv" feltételezés?</span> A "naiv" jelző arra utal, hogy feltételezzük az <span class="highlight">attribútumok függetlenségét</span>, ami a gyakorlatban gyakran nem teljesül, de mégis jó eredményeket ad.</p>
                <p><span class="key-point">Fő különbség:</span> A Bayes és a Naiv Bayes algoritmusok közötti legfontosabb eltérés a <span class="highlight">bemeneti változók közötti függetlenség feltételezésében</span> rejlik.</p>
                
                <div class="step">
                    <p><span class="key-point">Bayes algoritmus:</span></p>
                    <ul>
                        <li><span class="highlight">Figyelembe veszi</span> a változók közötti összefüggéseket</li>
                        <li>Pontosabb, de <span class="highlight">számításigényesebb</span></li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Naiv Bayes algoritmus:</span></p>
                    <ul>
                        <li><span class="highlight">Feltételezi a változók függetlenségét</span> az osztálycímke ismeretében</li>
                        <li>Egyszerűbb és <span class="highlight">gyorsabb</span>, de potenciálisan kevésbé pontos</li>
                    </ul>
                </div>
                <p><span class="key-point">Alkalmazás:</span> A választás a két módszer között függ a <span class="highlight">probléma jellegétől, az adatok mennyiségétől és a rendelkezésre álló számítási kapacitástól</span>.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>3. Gépi tanulás alapjai</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Gépi tanulás definíciója</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A gépi tanulás a <span class="highlight">tapasztalati (megfigyelt) tények felhasználása</span> arra, hogy egy <span class="highlight">racionális ágens teljesítményét növeljük</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Fő típusok:</span></p>
                    <ul>
                        <li><span class="highlight">Felügyelt (induktív) tanulás</span></li>
                        <li><span class="highlight">Felügyelet nélküli tanulás</span></li>
                        <li><span class="highlight">Megerősítéses tanulás</span></li>
                    </ul>
                </div>

                <p><span class="key-point">Előnyök:</span></p>
                <ul>
                    <li><span class="highlight">Automatizálás:</span> Komplex feladatok automatikus végrehajtása</li>
                    <li><span class="highlight">Adaptivitás:</span> Alkalmazkodás változó környezetekhez és új adatokhoz</li>
                    <li><span class="highlight">Skálázhatóság:</span> Nagy mennyiségű adat hatékony feldolgozása</li>
                </ul>

                <p><span class="key-point">Kihívások:</span></p>
                <ul>
                    <li><span class="highlight">Adatminőség:</span> A tanulás eredményessége függ a rendelkezésre álló adatok minőségétől</li>
                    <li><span class="highlight">Interpretálhatóság:</span> Egyes modellek "fekete dobozként" működnek, nehezen értelmezhetők</li>
                    <li><span class="highlight">Etikai kérdések:</span> Adatvédelem, torzítások kezelése</li>
                </ul>

                <p><span class="key-point">Mi a reprezentáció szerepe a gépi tanulásban?</span> Az X és Y halmazok <span class="highlight">tetszőleges objektumokat írhatnak le</span>, és fontos, hogy ezeket hogyan reprezentáljuk. Például szövegeknek sokfajta reprezentációja lehet, a tartalmazott szavak listájától a folytonos szemantikus beágyazásokig.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Felügyelt tanulás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a felügyelt tanulás?</span> Egy <span class="highlight">f: X → Y függvényt keresünk</span>, amely illeszkedik adott példákra. Példák formája: <span class="highlight">(x1, f(x1)), ..., (xn, f(xn))</span>, ahol x<sub>i</sub> ∈ X</p>
                
                <p><span class="key-point">Mire példa a felügyelt tanulás?</span> Például X: emailek halmaza, Y = {spam, nem spam}, a példák pedig kézzel osztályozott emailek. Ez lehet egy <span class="highlight">spam szűrő tanítása</span>.</p>

                <p><span class="key-point">Előnyök:</span></p>
                <ul>
                    <li><span class="highlight">Pontosság:</span> Jól definiált célok és címkézett adatok esetén magas pontosság érhető el</li>
                    <li><span class="highlight">Egyértelmű kiértékelés:</span> A modell teljesítménye könnyen mérhető a címkézett adatokon</li>
                    <li><span class="highlight">Széles alkalmazási terület:</span> Osztályozás, regresszió, előrejelzés számos területen</li>
                </ul>

                <p><span class="key-point">Algoritmusok:</span></p>
                <ul>
                    <li><span class="highlight">Lineáris regresszió</span></li>
                    <li><span class="highlight">Logisztikus regresszió</span></li>
                    <li><span class="highlight">Támogató vektorgépek (SVM)</span></li>
                    <li><span class="highlight">Neurális hálózatok</span></li>
                </ul>
            </div>
        </div>

        <div class="algorithm">
            <h2>Felügyelet nélküli tanulás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a felügyelet nélküli tanulás?</span> A példák csak <span class="highlight">x1, ..., xn alakban adottak</span> (xi ∈ X), és nem függvényt kell keresni, hanem <span class="highlight">mintázatokat</span> (pl. eloszlást).</p>

                <p><span class="key-point">Mire használjuk a felügyelet nélküli tanulást?</span> Például <span class="highlight">klaszterezésre</span> vagy <span class="highlight">dimenziócsökkentésre</span>, ahol a cél az adatok struktúrájának feltárása címkék nélkül.</p>
                <p><span class="key-point">Előnyök:</span></p>
                <ul>
                    <li><span class="highlight">Címkézetlen adatok használata:</span> Nem igényel előzetes emberi annotációt</li>
                    <li><span class="highlight">Rejtett struktúrák feltárása:</span> Olyan mintázatokat is felfedezhet, amelyeket emberi szakértők nem vennének észre</li>
                    <li><span class="highlight">Adatelőkészítés:</span> Hasznos lehet más gépi tanulási feladatok előkészítésében</li>
                </ul>

                <p><span class="key-point">Algoritmusok:</span></p>
                <ul>
                    <li><span class="highlight">K-közép klaszterezés</span></li>
                    <li><span class="highlight">Hierarchikus klaszterezés</span></li>
                    <li><span class="highlight">Főkomponens-analízis (PCA)</span></li>
                    <li><span class="highlight">Autokóderek</span></li>
                </ul>

                <p><span class="key-point">Alkalmazási területek:</span> Piaci szegmentálás | Anomália detektálás | Ajánlórendszerek | Génexpresszió-elemzés</p>

            </div>
        </div>

        <div class="algorithm">
            <h2>Megerősítéses tanulás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a megerősítéses tanulás?</span> Itt is létezik az X → Y függvény, de <span class="highlight">tanuló példák nem adottak direkt módon</span>. A feladat az, hogy egy állapottérben az ágens megtanulja az <span class="highlight">optimális stratégiát</span> úgy, hogy a <span class="highlight">jövőben</span> érintett állapotokban összegyűjtött <span class="highlight">jutalmak maximalizálását</span> érje el. <br><em>X az állapotok, Y a cselekvések halmaza</em></p>

                <p><span class="key-point">Miben különbözik a megerősítéses tanulás a többi módszertől?</span><br> A megerősítéses tanulásban az ágens <span class="highlight">interakcióba lép a környezetével</span>, és a kapott visszajelzések <span class="highlight">(jutalmak vagy büntetések) alapján tanulja meg a legjobb stratégiát. <span class="highlight">Dinamikusan</span> változó környezetekben is hatékony. <span class="highlight">Hosszú távú </span>stratégiák kialakítására képes</p>

                <p><span class="key-point">Algoritmusok:</span></p>
                <ul>
                    <li><span class="highlight">Q-tanulás</span></li>
                    <li><span class="highlight">SARSA (State-Action-Reward-State-Action)</span></li>
                    <li><span class="highlight">Politika gradiens módszerek</span></li>
                    <li><span class="highlight">Deep Q-Network (DQN)</span></li>
                </ul>

                <p><span class="key-point">Alkalmazási területek:</span> Robotika | Játékok (pl. Go, sakk) | Autonóm járművek | Erőforrás-menedzsment</p>

                <p><span class="key-point">Kihívások:</span></p>
                <ul>
                    <li><span class="highlight">Felfedezés vs. kiaknázás egyensúlyának megtalálása:</span> Az ágensnek egyensúlyt megtalálása az új lehetőségek feltárása és a már ismert jó stratégiák alkalmazása között</li>
                    <li><span class="highlight">Késleltetett jutalom:</span> A cselekvések hosszú távú következményeinek értékelése</li>
                    <li><span class="highlight">Skálázhatóság:</span> Nagy állapotterekben való hatékony működés</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>4. Döntési fák</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Döntési fák alapjai</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A döntési fa egy <span class="highlight">felügyelt tanulási módszer</span>, ahol x ∈ X diszkrét változók értékeinek vektora, és f(x) ∈ Y egy diszkrét változó egy értéke.</p>
                
                <div class="step">
                    <p><span class="key-point">Jellemzők:</span></p>
                    <ul>
                        <li>Y véges halmaz (pl. Y = {igen, nem})</li>
                        <li><span class="highlight">Osztályozási feladat</span>: X elemeit osztályokba soroljuk</li>
                        <li>Az X halmaz a változók értékeinek vektora, minden változó diszkrét</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Hogyan működik a döntési fa?</span> A fa <span class="highlight">gyökerétől a levelekig haladva</span> az attribútumok értékei alapján döntünk, míg el nem érünk egy levelet, amely megadja az osztályozás eredményét.</p>
                
                <p><span class="key-point">Mi a döntési fák előnye?</span> A döntési fák <span class="highlight">könnyen értelmezhetők/magyarázhatók</span> és vizualizálhatók (literally egy fa kb.), valamint hatékonyan kezelik a <span class="highlight">kategorikus és numerikus adatokat</span> is. Illetve <span class="highlight"> nem feltételez előzetes eloszlást az adatokról</span>.</p>
                
                <p><span class="key-point">Előnyök:</span></p>
                <ul>
                    <li><span class="highlight">Interpretálhatóság:</span> A döntések könnyen értelmezhetők és magyarázhatók</li>
                    <li><span class="highlight">Vizualizálhatóság:</span> A fa struktúra könnyen ábrázolható és érthető</li>
                    <li><span class="highlight">Nem paraméteres módszer:</span> Nem feltételez előzetes eloszlást az adatokról</li>
                    <li><span class="highlight">Kevert adattípusok kezelése:</span> Kategorikus és numerikus változókat egyaránt tud kezelni</li>
                </ul>
                
                <p><span class="key-point">Hátrányok:</span></p>
                <ul>
                    <li><span class="highlight">Túlillesztés veszélye:</span> Komplex fák esetén könnyen túlilleszkedhet a tanító adatokra</li>
                    <li><span class="highlight">Instabilitás:</span> Kis változások az adatokban jelentősen módosíthatják a fa struktúráját</li>
                    <li><span class="highlight">Lokális optimum:</span> A mohó építési stratégia miatt nem mindig találja meg a globális optimumot</li>
                    <li><span class="highlight">Korlátozott pontosság:</span> Egyes komplex problémáknál más módszerek (pl. neurális hálók) pontosabbak lehetnek</li>
                </ul>
                

                <p><span class="key-point">Példa:</span> Döntés, hogy érdemes-e asztalra várni egy étteremben.</p>
                <img src="../assets/images/dontesi_fa.webp" alt="Döntési fa példa" class="graph-image">
            </div>
        </div>
        
        <div class="algorithm">
            <h2>Zajszűrés</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A zajszűrés a <span class="highlight">túlillesztés problémájának kezelésére</span> szolgál, ahol a modell túlságosan pontosan illeszkedik az adatokra.</p>
                
                <div class="step">
                    <p><span class="key-point">Okok:</span></p>
                    <ul>
                        <li>Túl általános modell</li>
                        <li>Túl kevés példa</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Következmény:</span> A zaj reprezentálása a lényeg helyett, ami csökkenti az általánosítási képességet.</p>
                
                <div class="step">
                    <p><span class="key-point">Megoldások:</span></p>
                    <ul>
                        <li>Az <span class="highlight">információnyereség statisztikai szignifikanciájának</span> vizsgálata</li>
                        <li>Irreleváns attribútumok kiszűrése</li>
                        <li><span class="highlight">Keresztvalidáció:</span> A modell teljesítményének értékelése különböző adathalmazokon</li>
                        <li><span class="highlight">Együttes módszerek:</span> Több döntési fa kombinálása (pl. véletlen erdők)</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Példa:</span> Dobókockás példák irreleváns attribútumokkal (szín, dobás ideje), amelyek információnyeresége elméletben nulla, de a gyakorlatban értelmetlen döntési fát eredményezhetnek.</p>

                <p><span class="key-point">Előnyök:</span></p>
                <ul>
                    <li><span class="highlight">Jobb általánosítási képesség:</span> A modell jobban teljesít új, ismeretlen adatokon</li>
                    <li><span class="highlight">Egyszerűbb modellek:</span> A zajszűrés gyakran egyszerűbb, értelmezhetőbb fákat eredményez</li>
                    <li><span class="highlight">Robusztusabb predikciók:</span> A modell kevésbé érzékeny az adatok kis változásaira</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>5. Modellillesztés a gépi tanulásban</h2>
    </div>
    <div class="main-content">
        <p>I DONT HAVE MUCH INFO ON THIS</p><br>

        <p><span class="key-point">hipotézis:</span>  input alapján → címke, osztály</p>
        <p><span class="key-point">veszteségfüggvény:</span>  az adott x,y példán a h hipotézis mekkorát hibázik (X x Y x H → R)</p>
        <p><span class="key-point">tervezéshez szükséges:</span></p>
        <ol>
            <li><span class="highlight">hipotézistér:</span> milyen fajta modellek körében keresünk</li>
            <li><span class="highlight">veszteségfüggvény:</span> pl négyzetes hiba</li>
            <li><span class="highlight">az optimalizáló algoritmus</span></li>
        </ol>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>6. Mesterséges neuronhálók</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Különálló neuron</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A mesterséges neuron egy <span class="highlight">matematikai modell</span>, amely az emberi agy neuronjainak működését utánozza egyszerűsített formában.</p>
                
                <img src="../assets/images/neuron_model.bmp" alt="Mesterséges neuron modell" class="graph-image">
                <div class="step">
                    <p><span class="key-point">Komponensek:</span></p>
                    <ul>
                        <li><span class="highlight">Bemeneti kapcsolatok (xj):</span> Az információ fogadására szolgálnak</li>
                        <li><span class="highlight">Súlyok (wj):</span> A bemenetek fontosságát jelzik</li>
                        <li><span class="highlight">Összegző függvény (Σ):</span> A súlyozott bemenetek összegzése</li>
                        <li><span class="highlight">Aktivációs függvény (g):</span> A neuron kimenetét meghatározó nemlineáris függvény</li>
                        <li><span class="highlight">Eltolássúly (w0):</span> Az aktivációs küszöb beállítására szolgál</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Hogyan működik a neuron matematikailag?:</span></p>
                <img src="../assets/images/neuron_equation.bmp" alt="Neuron matematikai egyenlete" class="graph-image">
                <ul>
                    <li><span class="highlight">xj</span> a j. bemeneti érték</li>
                    <li><span class="highlight">wj</span> a j. bemenet súlya</li>
                    <li><span class="highlight">w0</span> az eltolássúly (bias weight)</li>
                    <li><span class="highlight">x0</span> fix bemenet, értéke mindig -1</li>
                </ul>
                <p><span class="key-point">Mi történik az összegzés után?</span> A neuron először kiszámolja ezt az összeget, <span class="highlight">majd az összeg végeredményén alkalmazza az aktivációs függvényt</span>.</p>
                <p><span class="key-point">Milyen típusúak lehetnek a bemenetek és súlyok?</span> A bemenetek általában <span class="highlight">tetszőleges valós számok</span> lehetnek, bár néhány alkalmazásban lehetnek korlátozottak is. A súlyok is <span class="highlight">valós számok</span>.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Aktivációs függvények</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> Az aktivációs függvény határozza meg a neuron kimenetét a súlyozott bemenetek összege alapján.</p>
                
                <img src="../assets/images/activation_functions.bmp" alt="Aktivációs függvények" class="graph-image">
                
                <div class="step">
                    <p><span class="key-point">Típusok:</span></p>
                    <ul>
                        <li><span class="highlight">Küszöbfüggvény:</span> g(x) = 0 ha x ≤ 0, g(x) = 1 ha x > 0</li>
                        <li><span class="highlight">Szigmoid függvény:</span> g(x) = 1 / (1 + e^(-x))</li>
                        <li><span class="highlight">ReLU (Rectified Linear Unit):</span> g(x) = max(0, x)</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mire szolgál az aktivációs függvény?</span> Az aktivációs függvény <span class="highlight">nemlinearitást visz a rendszerbe</span>, lehetővé téve komplex függvények approximációját.</p>

                <p><span class="key-point">Megjegyzés:</span> A modern aktivációs függvényekkel szemben nem követelmény, hogy a [0, 1] intervallumból adjanak értéket, de nemlineárisnak kell lenniük.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Neuron mint osztályozó</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> Egy neuron <span class="highlight">lineáris osztályozóként</span> működik, a bemeneti teret két részre osztva egy hipersíkkal.</p>
                
                <img src="../assets/images/neuron_classifier.webp" alt="Neuron mint osztályozó" class="graph-image">
                
                <div class="step">
                    <p><span class="key-point">Működés:</span></p>
                    <ul>
                        <li>A w · x = 0 egyenlet egy d-1 dimenziós hipersíkot határoz meg</li>
                        <li>Az eltolássúly (w0) miatt a hipersík nem feltétlenül megy át az origón</li>
                        <li>A neuron elfogadja az inputot, ha w · x > 0, egyébként nem</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Korlátozás:</span> Csak <span class="highlight">lineárisan szeparálható függvények</span> reprezentálhatók hiba nélkül egy neuronnal.</p>
                
                <p><span class="key-point">Példa:</span> A XOR logikai művelet nem lineárisan szeparálható, ezért egy neuronnal nem reprezentálható.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Többrétegű neuronhálózatok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a többrétegű neuronhálózat?</span> A többrétegű hálózat <span class="highlight">egymásra épülő neuronrétegekből</span> áll, amelyek képesek komplex mintázatok tanulására.</p>

                <div class="step">
                    <p><span class="key-point">Felépítés:</span></p>
                    <ul>
                        <li><span class="highlight">Bemeneti réteg:</span> Az adatok fogadására szolgál</li>
                        <li><span class="highlight">Rejtett rétegek:</span> Összetett összefüggések modellezésére</li>
                        <li><span class="highlight">Kimeneti réteg:</span> A végső eredmény előállítására</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Jellemzők:</span></p>
                <ul>
                    <li><span class="highlight">Előrecsatolt kapcsolatok:</span> Az információ a bemenettől a kimenet felé halad</li>
                    <li><span class="highlight">Nemlinearitás:</span> A rejtett rétegek és aktivációs függvények miatt képes nemlineáris függvények approximációjára</li>
                    <li><span class="highlight">Tanulási képesség:</span> A súlyok optimalizálásával képes mintázatok felismerésére és általánosításra</li>
                </ul>
                
                <p><span class="key-point">Mik a neuronhálók előnyei?</span> A neuronhálók képesek <span class="highlight">komplex nemlineáris összefüggések modellezésére</span>, jól skálázható, és automatikusan tanulnak jellemzőket az adatokból.</p>
                
                <p><span class="key-point">Mik a kihívások?</span> A fő kihívások közé tartozik a <span class="highlight">túltanulás kezelése</span>, a megfelelő hálózati architektúra kiválasztása, és a nagy számítási igény. A <span class="highlight">"fekete doboz"</span> jelleg miatt nehezen interpretálható modellek</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>7. k-NN osztályozó</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>k-NN alapjai</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A k-NN (k Nearest Neighbor) osztályozó egy <span class="highlight">nem paraméteres algoritmus</span>, amely a minták közötti távolság alapján osztályoz új mintákat.</p>
                
                <div class="step">
                    <p><span class="key-point">Működési elv:</span></p>
                    <ol>
                        <li>Tanuló adatkészlet használata, amely tartalmazza a mintákat és osztálycímkéket</li>
                        <li>Új minta esetén meghatározzuk a <span class="highlight">k legközelebbi ismert mintát</span> a távolság alapján</li>
                        <li>Az új minta osztálycímkéjét a k legközelebbi minta osztálycímkéi alapján határozzuk meg</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Mit jelent a k érték?</span> A k a figyelembe vett <span class="highlight">legközelebbi szomszédok számát</span> jelöli. Ennek megválasztása kritikus a modell teljesítménye szempontjából.</p>

                <p><span class="key-point">Hogyan mérjük a távolságot?</span> Általában <span class="highlight">euklideszi távolságot</span> használunk, de más mértékek (pl. Manhattan távolság) is alkalmazhatók a probléma jellegétől függően.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Szavazási módszerek</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Milyen szavazási módszereket használhatunk?</span></p>
                <div class="step">
                    <p><span class="key-point">1. Többségi szavazás:</span></p>
                    <ul>
                        <li>Az új minta osztálycímkéje a <span class="highlight">leggyakoribb címke</span> a k legközelebbi mintában</li>
                        <li><span class="highlight">Példa:</span> Ha k = 3, és 2 "A" osztályú és 1 "B" osztályú minta van, az új minta "A" osztályba kerül</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">2. Súlyozott szavazás:</span></p>
                    <ul>
                        <li>A szomszédok szavazatait a <span class="highlight">távolság reciprokával súlyozzuk</span></li>
                        <li>Közelebbi szomszédok nagyobb súlyt kapnak</li>
                        <li>Hasznos, ha a k legközelebbi minta nem egyenletesen oszlik el a távolság alapján</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Mi az 1-NN?</span> A k-NN speciális esete, ahol k = 1. Az új minta osztálycímkéjét a <span class="highlight">legközelebbi ismert minta</span> osztálycímkéje határozza meg.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Előnyök és hátrányok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <div class="step">
                    <p><span class="key-point">Előnyök:</span></p>
                    <ul>
                        <li><span class="highlight">Egyszerű implementáció és értelmezés</span></li>
                        <li>Hatékony kis adatbázisok esetén</li>
                        <li>Nem feltételezi a lineárisan szeparálható osztályokat</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Hátrányok:</span></p>
                    <ul>
                        <li>A teljesítmény romlik <span class="highlight">nagy adatbázisok</span> esetén</li>
                        <li><span class="highlight">Érzékeny a zajra és az outlierekre</span></li>
                        <li>A k paraméter kiválasztása befolyásolhatja a teljesítményt</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="algorithm">
            <h2>k-NN példa: Virágok osztályozása</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Példa:</span> Tegyük fel, hogy van egy tanuló adatkészletünk, amely virágokról szól, és a virágok osztályai <span class="highlight">"írisz" és "rózsa"</span>. Minden virágot négy jellemzővel jellemezünk: <span class="highlight">szirmok hossza, szirmok szélessége, cseplesz hossza és cseplesz szélessége</span>.</p>
        
                <p>Ha egy új virágot szeretnénk osztályozni, <span class="highlight">kiszámítjuk a távolságát</span> a tanuló adatkészletbeli minden virághoz. Ezután <span class="highlight">meghatározzuk a k legközelebbi virágot</span>, és az új virág osztálycímkéjét a k legközelebbi virág osztálycímkéi alapján határozzuk meg.</p>
        
                <p><span class="key-point">Megjegyzés:</span> A módszer hatékonysága függ a <span class="highlight">k érték megfelelő megválasztásától</span> és a <span class="highlight">jellemzők normalizálásától</span>.</p>
            </div>
        </div>        
    </div>

    <script src="../assets/js/tetel.js"></script>
</body>
</html>