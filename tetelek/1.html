<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tétel 1 - Alga I.</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../assets/css/tetel.css">
    <script defer data-domain="allamvizsga.netlify.app" src="https://plausible.io/js/script.js"></script>

</head>
<body class="dark-mode">
    <i class="fas fa-arrow-left back-button" id="backButton"></i>
    <i class="fas fa-adjust theme-toggle" id="themeToggle"></i>

	<h1>Algoritmusok és adatszerkezetek I - 1. tétel</h1>
    <p class="desc"><em>
        <span class="highlight">Részproblémára bontó algoritmusok</span><br>
        (mohó, oszd-meg-és-uralkodj, dinamikus programozás), <br>
        <span class="highlight">rendező algoritmusok, gráfalgoritmusok</span><br>
        (szélességi- és mélységi keresés, minimális feszítőfák, legrövidebb utak)
    </em></p>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>1. Részproblémára bontó algoritmusok</h2>
    </div>
    <div class="main-content">
		<div class="algorithm">
            <h2>1. Mohó algoritmusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a mohó algoritmus? </span>A mohó algoritmus <span class="highlight">minden lépésben az aktuálisan optimálisnak tűnő döntést hozza meg</span>, anélkül hogy figyelembe venné a jövőbeli következményeket.</p>
                <p><span class="key-point">Mikor alkalmazható? </span>A mohó algoritmus <span class="highlight">nem minden</span> problémára alkalmazható, viszont ahol igen, ott <span class="highlight">rendkívül gyors és hatékony</span> megoldást nyújt.</p>
                <p><span class="key-point">Cél:</span> A mohó választás <span class="highlight">egyetlen részproblémát eredményezzen</span>, amelyből közvetlenül következik az eredeti probléma optimális megoldása.</p>
                <p><span class="key-point">Előny:</span> <span class="highlight">Minimalizálja a rekurzív hívások számát</span>, csökkentve a probléma komplexitását.</p>
                <p><span class="key-point">Korlát:</span> Nem mindig találja meg a globális optimumot, mert <span class="highlight">a lokális optimumokat globálisként azonosíthatja</span>. Ezért körültekintően kell alkalmazni optimalizálási problémákra.</p>
                
                <h3>Példa: Töredékes hátizsák probléma</h3>
                <a href="https://youtu.be/oTTzNMHM05I" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Probléma leírása:</span> Van egy <span class="highlight">hátizsákunk és különböző tárgyaink</span>, amiket bele szeretnénk tenni. Minden tárgynak van <span class="highlight">értéke és súlya</span>, de a tárgyakat fel is darabolhatjuk.</p>
                <p><span class="key-point">Cél:</span> A lehető <span class="highlight">legtöbb értéket</span> vigyük magunkkal a hátizsák súlykorlátján belül.</p>
                <div class="step">
                    <p><span class="key-point">Mohó megoldás lépései:</span></p>
                    <ol>
                        <li><span class="highlight">Érték/súly arány</span> kiszámítása minden tárgyra.</li>
                        <li>Tárgyak <span class="highlight">sorba rendezése</span> az arány szerint, csökkenő sorrendben.</li>
                        <li>Tárgyak berakása a hátizsákba:
                            <ol>
                                <li>Ha egy tárgy teljesen belefér a hátizsákba, betesszük.</li>
                                <li>Ha nem fér be teljesen, annyit teszünk be belőle, amennyi még befér.</li>
                            </ol>
                        </li>
                        <li>Ezt addig folytatjuk, amíg a hátizsák meg nem telik.</li>
                    </ol>
                </div>
                <p><span class="key-point">Eredmény:</span> Ez a megközelítés <span class="highlight">optimális megoldást ad</span> a töredékes hátizsák problémára, mert mindig a legjobb <span class="highlight">"ár-érték arányú"</span> tárgyakat választjuk.</p>
            </div>
        </div>
		<div class="algorithm">
            <h2>2. Oszd-meg-és-uralkodj algoritmusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Lényeg:</span> A problémát <span class="highlight">kisebb, hasonló jellegű és független </span><strong>(diszjunkt)</strong><span class="highlight"> részfeladatokra bontja</span>.</p>

                <p><span class="key-point">Mikor hatékony?</span> A részfeladatok <span class="highlight">valóban függetlenek egymástól és nincsenek ismétlődések</span>.</p>
                <div class="step">
                    <p><span class="key-point">Az algoritmus három fő lépése:</span></p>
                    <ol>
                        <li><span class="highlight">Felosztás (Divide):</span> A probléma kisebb részproblémákra bontása.</li>
                        <li><span class="highlight">Megoldás (Conquer):</span> A részfeladatokat <span class="highlight">rekurzívan oldja meg</span>, szükség esetén tovább bontva őket.</li>
                        <li><span class="highlight">Összevonás:</span> A <span class="highlight">részfeladatok megoldásait összevonja</span> az eredeti probléma megoldásává.</li>
                    </ol>
                </div>
                <p><span class="key-point">Mi a rekurzió?</span> Egy olyan programozási technika, ahol egy függvény <span class="highlight">közvetlenül vagy közvetve meghívja önmagát</span> a probléma megoldása során.</p>

                <h3>Példa: Felező-csúcskereső algoritmus</h3>
                <div class="step">
                    <p><span class="key-point">Probléma:</span> Rendezett adathalmazban keresünk egy elemet.</p>
                    <p><span class="key-point">Lépések:</span></p>
                    <ol>
                        <li><span class="highlight">Felezzük le</span> a keresési tartomány. <br>(Osszuk két részre)</li>
                        <li><span class="highlight">Hasonlítsuk össze</span> a keresett elemet a középső elemmel.</li>
                        <li><span class="highlight">Válasszuk ki </span>a megfelelő <span class="highlight">felet</span> további keresésre.</li>
                        <li>Az 1-3 lépések <span class="highlight">ismétlése</span>, amíg meg nem találjuk az elemet vagy ki nem derül, hogy nincs benne.</li>
                    </ol>
                </div>
                <p><span class="key-point">Előny:</span> <span class="highlight">Sokkal gyorsabb</span>, mint a lineáris keresés, különösen nagy adathalmazok esetén.</p>
            
            </div>
        </div>
		<div class="algorithm">
            <h2>3. Dinamikus programozás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> Olyan módszer, amely <span class="highlight">komplex problémákat kisebb részproblémákra bont</span>, és ezek megoldásait tárolja a későbbi felhasználás céljából.</p>
                
                <div class="step">
                    <p><span class="key-point">Főbb jellemzők:</span></p>
                    <ul>
                        <li>Alkalmazható, amikor a részproblémák <span class="highlight">nem függetlenek </span><strong>(nem diszjunkt)</strong> egymástól.</li>
                        <li>Minden részfeladatot <span class="highlight">csak egyszer old meg</span>, az eredményeket tárolja.</li>
                        <li><span class="highlight">Elkerüli a felesleges újraszámításokat</span>, így hatékonyabb más módszereknél.</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Két fő megközelítés:</span></p>
                    <ol>
                        <li><span class="highlight">Iteratív (tabuláció):</span> Részmegoldásokat táblázatba tárolja, minden részmegoldást kiszámol, alulról felfelé építkezik.<br><em>(A legkisebb részproblémákkal kezdünk, majd fokozatosan építjük fel a végső megoldást.)</em></li>
                        <li><span class="highlight">Rekurzív memorizálással:</span> Részmegoldásokat kulcs-érték párokban tárolja, felülről lefelé halad, rekurzívan bontva kisebb részproblémákra.</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Alkalmazás:</span> Tipikusan <span class="highlight">optimalizálási feladatoknál</span>, ahol a cél a legjobb megoldás megtalálása.</p>
                
                <div class="step">
                    <h3>Példa: Fibonacci-sorozat</h3>
                    <p><span class="key-point">Probléma:</span> Az n-edik Fibonacci-szám kiszámítása.</p>
                    <p><span class="key-point">Dinamikus programozási megoldás:</span></p>
                    <ol>
                        <li><span class="highlight">Alapesetek definiálása:</span> F(0) = 0, F(1) = 1</li>
                        <li><span class="highlight">Készítünk egy táblázatot</span> a részeredmények tárolására.</li>
                        <li>Minden következő számot az előző kettő összegeként számolunk: <span class="highlight">F(n) = F(n-1) + F(n-2)</span></li>
                        <li>A táblázat segítségével <span class="highlight">elkerüljük a többszöri számítást</span>, ezzel jelentősen gyorsítva a folyamatot.</li>
                    </ol>
                </div>
                <p><span class="key-point">Eredmény:</span> <span class="highlight">Jelentősen csökkenti a számítási időt</span> a rekurzív megoldáshoz képest, különösen nagyobb számok esetén.</p>
                <img src="../assets/images/fibonacci.webp" alt="Fibonacci" class="graph-image">
            </div>
        </div>
        <div class="algorithm">
            <h2>4. D&C vs DP</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a fő különbség?</span> Bár mindkét módszer <span class="highlight">részproblémákra bontja</span> a feladatot, a megközelítésük és a részproblémák kezelése eltérő. A dinamikus programozás <span class="highlight">tárolja és újrahasználja</span> a részeredményeket, míg az oszd-meg-és-uralkodj <span class="highlight">minden részproblémát függetlenül old meg</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Példa: Fibonacci számítás</span></p>
                    <ul>
                        <li><span class="highlight">Oszd-meg-és-uralkodj:</span> 
                            <ul>
                                <li>Minden Fibonacci számot <span class="highlight">többször számol ki</span></li>
                                <li>Például: Fibonacci(5) = Fibonacci(4) + Fibonacci(3), és Fibonacci(4) = Fibonacci(3) + Fibonacci(2), stb.</li>
                                <li>Eredmény: <span class="highlight">Sok ismétlődő számítás és rekurzív hívás</span></li>
                                <li>Időkomplexitás: <span class="highlight">O(2^n)</span>, ami exponenciális növekedést jelent</li>
                            </ul>
                        </li>
                        <li><span class="highlight">Dinamikus programozás:</span>
                            <ul>
                                <li><span class="highlight">Táblázatot használ</span> az összes Fibonacci szám tárolására 1-től n-ig</li>
                                <li>A <span class="highlight">korábbi eredményeket újrafelhasználja</span></li>
                                <li>Például: Fibonacci(5) kiszámításánál felhasználja a már tárolt Fibonacci(4) és Fibonacci(3) értékeket</li>
                                <li>Időkomplexitás: <span class="highlight">O(n)</span>, ami lineáris időben oldja meg a problémát</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Összefoglalás:</span></p>
                    <ul>
                        <li><span class="highlight">Oszd-meg-és-uralkodj:</span>
                            <ul>
                                <li>Részproblémák <span class="highlight">függetlenek és diszjunktak</span></li>
                                <li><span class="highlight">Nincs tárolás</span> vagy memorizálás</li>
                                <li>Minden részproblémát <span class="highlight">újra megoldanak</span></li>
                                <li>Alkalmas olyan problémákra, ahol a részfeladatok <span class="highlight">nem fednek át</span></li>
                            </ul>
                        </li>
                        <li><span class="highlight">Dinamikus programozás:</span>
                            <ul>
                                <li>Részproblémák <span class="highlight">átfedhetnek</span></li>
                                <li><span class="highlight">Tárolja</span> a részeredményeket (memorizálás)</li>
                                <li><span class="highlight">Elkerüli az ismétlődő számításokat</span></li>
                                <li>Két fő megközelítése: <span class="highlight">felülről lefelé (memorizálás)</span> és <span class="highlight">alulról felfelé (tabuláció)</span></li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <p><span class="key-point">Melyik hatékonyabb?</span> Mindkét módszer <span class="highlight">hatékony lehet</span> a megfelelő problématípusoknál. Az oszd-meg-és-uralkodj jól működik <span class="highlight">független részproblémáknál</span>, mint a gyorsrendezés. A dinamikus programozás <span class="highlight">különösen hasznos</span> olyan problémáknál, ahol sok az ismétlődő részprobléma, mint a hátizsák probléma vagy a legrövidebb út keresése. A dinamikus programozás <span class="highlight">jelentős teljesítménynövekedést</span> érhet el az eredmények újrafelhasználásával, különösen nagy és komplex problémáknál.</p>
            </div>
        </div>
	</div>
	
	<div class="main-topic" onclick="toggleMainContent(this)">
        <h2>2. Rendező algoritmusok</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Rendező algoritmusok áttekintése</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p>A rendezési feladatok bemenete egy <span class="highlight">„n” elemű rendezetlen számsorozat</span>, a kimenete ennek az „n”
                    elemnek egy <span class="highlight">rendezett sorozata permutációja</span> amire igaz, hogy az első elemnél nagyobb a második és,
                    így tovább <code>a1 &lt; a2 &lt; na3 </code>. Egy rendezés <span class="highlight">stabil</span>, ha az input két egyenlő elem eredeti <span class="highlight">sorrendje egymáshoz képest</span> a rendezést követően megmarad.</p>
            </div>
        </div>
        <div class="algorithm">
            <h2>Beszúró rendezés (insertion sort)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=JU767SDMDvA" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Definíció:</span> A <span class="highlight">beszúró rendezés</span> egy <span class="highlight">egyszerű, de hatékony</span> algoritmus, különösen <span class="highlight">kisebb adathalmazok</span> esetén.</p>
                

                <p><span class="key-point">Működési elv:</span> Az algoritmus <span class="highlight">lépésenként építi fel a rendezett listát</span>, minden elemet a megfelelő helyre illesztve.</p>
                
                <div class="step">
                    <p><span class="key-point">Algoritmus lépései:</span></p>
                    <ol>
                        <li>Az algoritmus <span class="highlight">balról jobbra halad</span> a tömbön, a második elemtől kezdve.</li>
                        <li>Az aktuális elemet egy <span class="highlight">ideiglenes változóban</span> tárolja el.</li>
                        <li><span class="highlight">Összehasonlítja</span> az ideiglenes elemet a tőle balra lévő elemekkel.</li>
                        <li>A nagyobb elemeket <span class="highlight">jobbra mozgatja</span>, hogy helyet csináljon az ideiglenes elemnek.</li>
                        <li>Az ideiglenes elemet <span class="highlight">beszúrja</span> a megfelelő helyre (ahol az első tőle kisebb vagy egyenlő elemet találja).</li>
                        <li>Ezt a folyamatot <span class="highlight">ismétli minden elemre</span>, balról jobbra haladva.</li>
                    </ol>
                </div>

                <p><span class="key-point">Alkalmazás:</span> Hatékony <span class="highlight">kis adathalmazokra</span> vagy <span class="highlight">majdnem rendezett tömbökre</span>. Gyakran használják más, összetettebb rendezési algoritmusok részeként.</p>

                <p><span class="key-point">Futási idő:</span> Az algoritmus <span class="highlight">n-szer fut le</span>, ahol n a tömb elemeinek száma.</p>

                <div class="step">
                    <p><span class="key-point">Időkomplexitás:</span></p>
                    <ul>
                        <li>Átlagos és legrosszabb eset: <span class="highlight">O(n^2)</span></li>
                        <li>Legjobb eset (már rendezett tömb): <span class="highlight">O(n)</span></li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">Jellemzők:</span></p>
                    <ul>
                        <li><span class="highlight">Stabil rendezés:</span> Az egyenlő elemek relatív sorrendje nem változik.</li>
                        <li><span class="highlight">In-place algoritmus:</span> Helyben rendez, extra memória nélkül.</li>
                    </ul>
                </div>
                
            </div>
        </div>
        <div class="algorithm">
            <h2>Összefésülő rendezés (Mergesort)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=5Z9dn2WTg9o" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                
                <p><span class="key-point">Definíció:</span> Az <span class="highlight">összefésülő rendezés</span> egy <span class="highlight">"oszd meg és uralkodj"</span> elven működő hatékony rendezési algoritmus.</p>
                
                <p><span class="key-point">Működési elv:</span> Az algoritmus a problémát kisebb részekre bontja, megoldja azokat, majd egyesíti a megoldásokat.</p>
                
                <div class="step">
                    <p><span class="key-point">*Összefésülési folyamat (by ATTILA):</span></p>
                    <ul>
                        <li><span class="highlight">Felosztás:</span> A tömböt először isrekurzívan felosztjuk közel egyenlő részekre</li>
                        <li>Két rendezett résztömböt egyesítünk:</li>
                        <li>Összehasonlítjuk a résztömbök első elemeit.</li>
                        <li>A kisebb elemet az eredmény tömbbe helyezzük.</li>
                        <li>Ezt ismételjük, amíg minden elem a helyére nem kerül.</li>
                    </ul>
                </div>
                <div class="step">
                    <p><span class="key-point">Jellemzők:</span></p>
                    <ul>
                        <li><span class="highlight">Időigénye minden esetben: </span>Θ(n log n) <em>Théta</em>
                            <br><em>(Térkomplexitás: O(n))</em>
                        </li>
                        <li><span class="highlight">Stabil rendezés:</span> Az egyenlő elemek relatív sorrendje nem változik.</li>
                        <li><span class="highlight">Nem helyben rendez:</span> Extra memóriát igényel a műveletek során.</li>
                    </ul>
                </div>
        
                <div class="step">
                    <p><span class="key-point">Előnyök:</span></p>
                    <ul>
                        <li><span class="highlight">Hatékony nagy adathalmazokra:</span> Jól skálázódik nagyméretű adatok esetén.
                            <br><em>(Hátránya: Kis adathalmazokra más algoritmusok (pl. beszúró rendezés) hatékonyabbak lehetnek.)</em>
                        </li>
                        <li><span class="highlight">Garantált futásidő </span> minden esetben.</li>
                    </ul>
                </div>

                <p><span class="key-point">Alkalmazások:</span> Gyakran használják nagy adatbázisok rendezésére, külső rendezésre és olyan helyzetekben, ahol stabil rendezésre van szükség.</p>
            </div>
        </div>
        <div class="algorithm">
            <h2>Kupacrendezés (heapsort)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=mgUiY8CVDhU" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Definíció:</span> A kupacrendezés a <span class="highlight">kupac (heap) adatszerkezetet</span> használja, ami egy speciális <span class="highlight">bináris fa</span>.</p>
                <div class="step">
                    <p><span class="key-point">Algoritmus lépései:</span></p>
                    <ol>
                        <li><span class="highlight">Maximum kupac építése</span> a bemeneti tömbből.</li>
                        <li>Az elemek <span class="highlight">helyben rendezése</span> a kupac-tulajdonság megtartásával.</li>
                        <li>A rendezés folyamata:
                            <ol>
                                <li>A <span class="highlight">gyökérelem</span> (legnagyobb elem) kiírása a kimenetre.</li>
                                <li>A <span class="highlight">legszélső levél</span> áthelyezése a gyökérbe.</li>
                                <li>Ezzel sérül a kupac-tulajdonság, így<span class="highlight"> a kupactulajdonságot helyre kell állítani</span>.</li>
                            </ol>
                        </li>
                        <li>Ismétlés, amíg a <span class="highlight">kupac mérete 1 nem lesz</span>.</li>
                    </ol>
                </div>
                <div class="step">
                    <p><span class="key-point">Kupactulajdonság helyreállítása:</span></p>
                    <ol>
                        <li>A <span class="highlight">gyökér összehasonlítása</span> a gyerekeivel.</li>
                        <li><span class="highlight">Csere a nagyobb gyerekkel</span>, ha szükséges.</li>
                        <li><span class="highlight">Rekurzív folytatás</span> a módosított részfán.</li>
                    </ol>
                </div>

                <div class="step">
                    <p><span class="key-point">Kupac-tulajdonság:</span> A kupac minden gyökértől különböző elemére teljesül, hogy <span class="highlight">értéke nem lehet nagyobb, mint az apjáé</span> maximum kupac esetén. Minimum kupacnál ez fordítva igaz.</p>
                </div>
                <div class="step">
                    <p><span class="key-point">Jellemzők:</span></p>
                    <ul>
                        <li>Időigény: <span class="highlight">Θ(n * log n)</span>, ahol n a rendezendő elemek száma.</li>
                        <li><span class="highlight">Nem stabil</span> rendezés</li>
                        <li>De <span class="highlight">helyben rendez</span>,így  memóriahatékony</li>
                    </ul>
                </div>
                <div class="step">
                    <p><span class="key-point">Kupactulajdonság helyreállítása:</span></p>
                    <ol>
                        <li>A <span class="highlight">gyökér összehasonlítása</span> a gyerekeivel.</li>
                        <li><span class="highlight">Csere a nagyobb gyerekkel</span>, ha szükséges.</li>
                        <li><span class="highlight">Rekurzív folytatás</span> a módosított részfán.</li>
                    </ol>
                </div>
            </div>
        </div>
        <div class="algorithm">
            <h2>Gyorsrendezés (quicksort)</h2>
            
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=WprjBK0p6rw" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Definíció:</span> A gyorsrendezés egy <span class="highlight">egyszerű, de hatékony</span> <strong>oszd meg és uralkodj</strong> elven működő összehasonlító rendezési algoritmus.</p>
                
                <p><span class="key-point">Működése (Attila magyarázat):</span></p>
                <div class="step">
                    <p><span class="key-point">1. Pivot választás:</span> Kiválasztunk egy <span class="highlight">pivot elemet</span>. Általában az <span class="highlight">utolsó elemet</span> választjuk.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">2. Változók beállítása:</span> Két fő indexet használunk:</p>
                    <ul>
                        <li><span class="highlight">"current" index:</span> Az aktuálisan vizsgált elem</li>
                        <li><span class="highlight">"swap" index:</span> A következő csere helye</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">3. Particionálás:</span> A tömb felosztása:</p>
                    <ul>
                        <li>Mindkét index a <span class="highlight">tömb elején</span> kezd (0. index).</li>
                        <li><span class="highlight">Összehasonlítjuk</span> a current indexen álló számot a pivottal:</li>
                        <ul>
                            <li>Ha a pivot <span class="highlight">nagyobb:</span> Növeljük a swap indexet.</li>
                            <li>Ha a pivot <span class="highlight">kisebb:</span> Csere a swap és current indexen álló számok között, swap index nem változik (csak az értéke).</li>
                        </ul>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">4. Felosztás eredménye:</span> A tömb két részre oszlik:</p>
                    <ul>
                        <li>Pivot számnál <span class="highlight">kisebb elemek</span></li>
                        <li>Pivot számnál <span class="highlight">nagyobb elemek</span></li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">5. Rekurzió:</span> A folyamatot <span class="highlight">rekurzívan ismételjük</span> mindkét résztömbön, amíg minden résztömb mérete 1 nem lesz.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Időkomplexitás:</span></p>
                    <ul>
                        <li>Átlagos eset: <span class="highlight">O(n log n)</span></li>
                        <li>Legrosszabb eset: <span class="highlight">Θ(n^2)</span></li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Jellemzők:</span></p>
                    <ul>
                        <li><span class="highlight">Nem stabil</span> rendezés</li>
                        <li><span class="highlight">Helyben rendez</span>, memóriahatékony</li>
                        <li>Teljesítménye függ a <span class="highlight">pivot választástól</span></li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="algorithm">
            <h2>Leszámláló rendezés</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=7zuGmKfUt7s" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Definíció:</span> A leszámláló rendezés egy <span class="highlight">speciális rendezési algoritmus</span>, amit akkor használunk, ha a tömbben <span class="highlight">legfeljebb k-féle érték szerepel</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Algoritmus lépései:</span></p>
                    <ol>
                        <li><span class="highlight">Segédtömb létrehozása:</span> Egy k elemű segédtömb inicializálása.</li>
                        <li><span class="highlight">Elemek számlálása:</span> Az eredeti tömb elemeinek összeszámolása a segédtömbben.</li>
                        <li><span class="highlight">Kumulatív összegek:</span> Módosítjuk a segédtömb értékeit úgy, hogy <span class="highlight">minden tömbelem az őt megelőző elemek összegét tartalmazza.</span></li>
                        <li><span class="highlight">Elemek elhelyezése:</span> Az eredeti tömb elemeinek rendezett elhelyezése:
                            <ul>
                                <li><span class="highlight">Visszafelé iterálunk</span> az eredeti tömbön.</li>
                                <li>Minden elemet a <span class="highlight"></span>segédtömbben található indexre helyezünk.</li>
                                <li>Ezután <span class="highlight">csökkentjük a segédtömbben az adott elem számlálóját.</span></li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Időigénye:</span> <span class="highlight">O(n + k)</span>, ahol n az elemek száma, k a lehetséges értékek száma.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Jellemzők:</span></p>
                    <ul>
                        <li><span class="highlight">Lineáris futásidő:</span> Ha k = O(n), akkor a futásidő gyakorlatilag O(n).</li>
                        <li><span class="highlight">Stabil rendezés:</span> Az egyenlő elemek relatív sorrendje nem változik.</li>
                        <li><span class="highlight">Külső rendezés:</span> Extra memóriát használ a segédtömbhöz.</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Alkalmazás:</span> <span class="highlight">Rendkívül hatékony</span> ismert szűk értéktartományú adatok rendezésére, ahol az értéktartomány nem sokkal nagyobb, mint az elemek száma.</p>
                </div>
            </div>
        </div>
    </div>

	<div class="main-topic" onclick="toggleMainContent(this)">
        <h2>3. Gráfalgoritmusok</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Szélességi keresés (BFS)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=HZ5YTanv5QE" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Definíció:</span> A szélességi keresés (BFS) egy <span class="highlight">gráfbejárási algoritmus</span>, amely a csúcsokat a <span class="highlight">kezdőcsúcstól való távolságuk sorrendjében</span> járja be.</p>
                
                <div class="step">
                    <p><span class="key-point">Cél:</span> Bejárni az összes csúcsot, ami egy <span class="highlight">'s' kezdőcsúcsból elérhető</span>, miközben kiszámoljuk a távolságukat 's'-től.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Bemenet:</span> Irányított vagy irányítatlan gráf és annak egy 's' csúcsa.</p>
                    <p><span class="key-point">Kimenet:</span> Szótár, amely tartalmazza az <span class="highlight">s-ből elérhető csúcsokat és azok távolságát</span>.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Működése:</span></p>
                    <ul>
                        <li>Egy <span class="highlight">sorban tárolja</span> a még fel nem dolgozott csúcsokat.</li>
                        <li><span class="highlight">Rétegenként halad</span> a gráfban, minden lépéssel eggyel távolabb kerülve a kiindulási csúcstól.</li>
                        <li>A bejárás állapotát a csúcsok <span class="highlight">színezésével</span> tartja számon:
                            <ul>
                                <li><span class="highlight">Fehér:</span> Még nem felfedezett csúcs</li>
                                <li><span class="highlight">Szürke:</span> Felfedezett, de még nem teljesen feldolgozott csúcs</li>
                                <li><span class="highlight">Fekete:</span> Teljesen feldolgozott csúcs</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Időbonyolultság:</span> O(V + E), ahol V a csúcsok, E az élek száma.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Alkalmazások:</span></p>
                    <ul>
                        <li>Legrövidebb utak keresése <span class="highlight">súlyozatlan gráfokban</span></li>
                        <li>Összefüggőség vizsgálata</li>
                        <li>Navigációs programokban <span class="highlight">közelben lévő helyek</span> (pl. éttermek, benzinkutak) megtalálása</li>
                    </ul>
                </div>
                
                <p>A BFS egy <span class="highlight">szélességi fát</span> hoz létre, amely függ a kimenő élek bejárási sorrendjétől, de a távolságok egyértelműek.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Mélységi keresés (DFS)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://youtu.be/Urx87-NMm6c" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                </a>
                <p><span class="key-point">Definíció:</span> A mélységi keresés (DFS) egy <span class="highlight">gráfbejárási algoritmus</span>, amely a gráf ágait a <span class="highlight">lehető legmélyebbre követi</span>, mielőtt visszalépne.</p>
                
                <div class="step">
                    <p><span class="key-point">Cél:</span> Egy megoldás megtalálása, amely <span class="highlight">nem feltétlenül optimális</span>. Például egy út megtalálása két csúcs között.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Bemenet:</span> Irányított vagy irányítatlan gráf és egy kezdőcsúcs.</p>
                    <p><span class="key-point">Kimenet:</span> Mélységi feszítőerdő (MFE).</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Működése:</span></p>
                    <ul>
                        <li>A kiindulási csúcsból <span class="highlight">egy irányban halad</span> a gráf legmélyebb pontjáig.</li>
                        <li>Ha nem tud tovább haladni, <span class="highlight">visszalép</span> és új, fel nem fedezett utat keres.</li>
                        <li>Megvalósítása lehet <span class="highlight">rekurzív vagy iteratív</span>.</li>
                        <li>A csúcsokat színezi és meghatározza róluk az <span class="highlight">elérési időt, elhagyási időt és a szülőt</span>.</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Csúcsok állapota:</span></p>
                    <ul>
                        <li><span class="highlight">Fehér:</span> Még nem felfedezett csúcs</li>
                        <li><span class="highlight">Szürke:</span> Felfedezett, de még nem teljesen feldolgozott csúcs</li>
                        <li><span class="highlight">Fekete:</span> Teljesen feldolgozott csúcs</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Élek osztályozása a MFE-ben:</span></p>
                    <ul>
                        <li><span class="highlight">Faél:</span> (u,v) faél, ha bekerül a MFE élei közé, azaz π(v) = u</li>
                        <li><span class="highlight">Visszaél:</span> (u,v) visszaél, ha u leszármazottja v-nek a MFE-ben</li>
                        <li><span class="highlight">Előreél:</span> (u,v) előreél, ha v leszármazottja u-nak a MFE-ben és nem faél</li>
                        <li><span class="highlight">Keresztél:</span> minden más esetben</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Alkalmazások:</span></p>
                    <ul>
                        <li>Labirintus feladatok megoldása</li>
                        <li>Erősen összefüggő komponensek keresése</li>
                        <li>Topológiai rendezés</li>
                    </ul>
                </div>
                
                <p>A DFS <span class="highlight">nem feltétlenül optimális</span> megoldást ad, de gyorsan megtalálja a lehetséges megoldásokat.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Minimális feszítőfa</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                
                <p>A minimális feszítőfa egy <span class="highlight">összefüggő, körmentes élhalmaz</span>, amely tartalmazza az eredeti gráf összes csúcsát, és az <span class="highlight">élköltségek összege minimális</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Bemenet:</span> Összefüggő, irányítatlan, súlyozott G=(V, E) gráf, ahol V a csúcsok halmaza, E az élek halmaza, és w(u, v) az (u, v) él költsége.</p>
                    <p><span class="key-point">Kimenet:</span> Minden csúcsot érintő, körmentes, összefüggő, minimális költségű élhalmaz.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Tulajdonságok:</span></p>
                    <ul>
                        <li>Tartalmazza az összes csúcsot</li>
                        <li>N-1 éle van, ahol N a csúcsok száma</li>
                        <li>Több azonos súlyú él esetén több minimális feszítőfa is lehetséges</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Algoritmusok:</span></p>
                    <h3>1. Kruskal algoritmus</h3>
                    <a href="https://youtu.be/71UQH7Pr9kU" class="algorithm-link" target="_blank">
                        <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                    </a>
                    <ul>
                        <li><span class="highlight">Mohó elven</span> működik</li>
                        <li>Minimális fák erdejét tárolja</li>
                        <li>Kezdetben minden pont külön fa</li>
                        <li>Lépésenként a <span class="highlight">legkisebb súlyú élet</span> húzza be, ami két fát összeköt, és nem hoz létre 'cicle'</li>
                        <li>Időbonyolultság: <span class="highlight">O(E log E)</span>, ahol E az élek száma</li>
                    </ul>
                </div>
                <div class="step">
                    <h3>2. Prim algoritmus</h3>
                    <a href="https://youtu.be/cplfcGZmX7I" class="algorithm-link" target="_blank">
                        <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                    </a>
                    <ul>
                        <li>Szintén <span class="highlight">mohó algoritmus</span></li>
                        <li>Egy tetszőleges gyökérpontból <span class="highlight">egyetlen fát növeszt</span></li>
                        <li>Minden lépésben egy új csúcsot köt be a legkisebb költségű élen keresztül</li>
                        <li>Időbonyolultság: <span class="highlight">O(E log V)</span> bináris kupaccal <br>(V a csúcsok, E az élek száma)</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Fontos megjegyzések:</span></p>
                    <ul>
                        <li>Ha minden élsúly különböző, a két algoritmus <span class="highlight">azonos eredményt ad</span></li>
                        <li>A minimális feszítőfa <span class="highlight">nem feltétlenül egyedi</span></li>
                        <li>Mindkét algoritmus <span class="highlight">garantáltan megtalálja</span> a minimális feszítőfát</li>
                    </ul>
                </div>
                
                <p>A minimális feszítőfa probléma megoldása fontos szerepet játszik <span class="highlight">hálózattervezésben</span> és más optimalizálási feladatokban.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Legrövidebb utak</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Definíció:</span> A legrövidebb utak <span class="highlight">(dinam. prog.)</span> probléma célja, hogy megtaláljuk a <span class="highlight">minimális költségű utat</span> egy adott kezdőcsúcsból az összes többi csúcsba egy súlyozott gráfban.</p>
                
                <div class="step">
                    <p><span class="key-point">Bemenet:</span> Irányított, súlyozott G=(V, E) gráf, ahol V a csúcsok halmaza, E az élek halmaza, w(u, v) az (u, v) él súlya, és egy s kezdőcsúcs.</p>
                    <p><span class="key-point">Kimenet:</span> Minden V csúcshoz vezető legrövidebb út s-ből indulva.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Dijkstra algoritmus:</span></p>
                    <ul>
                        <li><span class="highlight">Mohó algoritmus</span>, amely mindig a legközelebbi, még nem feldolgozott csúcsot választja</li>
                        <li>Minden lépésben <span class="highlight">legrövidebb úttal bíró csúcsot választja</span>, ezzel <span class="highlight">bővíti az elért csúcsok halmazát</span></li>
                        <li>Időbonyolultság: <span class="highlight">O(E log V)</span> bináris kupac használatával</li>
                        <li>A legrövidebb út <span class="highlight">részútja is legrövidebb út</span></li>
                        <li>Alkalmazás: GPS útvonaltervezés</li>
                    </ul>
                </div>
                <div class="step">
                    <p><span class="key-point">Dijkstra algoritmus működése:</span></p>
                    <a href="https://youtu.be/_lHSawdgXpI" class="algorithm-link" target="_blank">
                        <i class="fas fa-video"></i> Youtube vizuális elmagyarázva
                    </a>
                    <ol>
                        <li>Kezdetben a kezdőcsúcs távolsága 0, minden más csúcsé ∞</li>
                        <li>Kiválasztjuk a <span class="highlight">legkisebb távolságú, még nem feldolgozott csúcsot</span></li>
                        <li>Megvizsgáljuk a kiválasztott csúcs szomszédjait</li>
                        <li>Ha találunk <span class="highlight">rövidebb utat egy szomszédhoz</span>, frissítjük annak távolságát</li>
                        <li>A kiválasztott csúcsot megjelöljük feldolgozottként</li>
                        <li>Ismételjük a 2-5 lépéseket, amíg minden csúcsot fel nem dolgoztunk</li>
                    </ol>
                </div>

                <span class="key-point">Korlája:</span><span class="highlight"> Nem működik negatív élsúlyú körök</span> esetén
                <p>A Dijkstra hibáira <span class="highlight">megoldást</span> nyújthat a <span class="highlight">Bellman-Ford algoritmus</span></p>
                
                <div class="step">
                    <p><span class="key-point">Bellman-Ford algoritmus:</span></p>
                    <ul>
                        <li>Működik <span class="highlight">negatív élsúlyok</span> esetén is</li>
                        <li>Észleli a <span class="highlight">negatív körök</span> jelenlétét</li>
                        <li>Időbonyolultság: <span class="highlight">O(VE)</span>, ahol V a csúcsok, E az élek száma</li>
                        <li><span class="key-point">Működése:</span>
                            <ol>
                                <li>Kezdőcsúcs távolsága 0, többi csúcs távolsága ∞</li>
                                <li>V-1 iterációban minden élre elvégezzük a relaxációt</li>
                                <li>Ha V. iterációban is találunk javítást, negatív kört észleltünk</li>
                            </ol>
                        </li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Fontos megjegyzések:</span></p>
                    <ul>
                        <li>Dijkstra algoritmusa <span class="highlight">körökkel boldogul</span>, de negatív élsúlyokkal nem</li>
                        <li>Negatív összsúlyú körök esetén a <span class="highlight">legrövidebb út nem értelmezhető</span></li>
                        <li>Bellman-Ford algoritmusa <span class="highlight">lassabb, de általánosabb</span> megoldást nyújt</li>
                    </ul>
                </div>
                
                <p>A legrövidebb utak problémája fontos szerepet játszik <span class="highlight">hálózati forgalomirányításban</span>, <span class="highlight">útvonaltervezésben</span> és számos más alkalmazási területen.</p>
            </div>
        </div>
    </div>
    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>Összegzés</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Mohó algoritmus</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li>Az algoritmus <span class="highlight">minden lépésben az optimálisnak tűnő döntést</span> hozza meg</li>
                    <li>Példa: <span class="highlight">hátizsák probléma</span> (töredékes és ismétléses változat)</li>
                    <li>Nem minden problémára alkalmazható, de ha igen, akkor <span class="highlight">rendkívül hatékony</span></li>
                    <li>Cél: egy részprobléma kapása, amelyből közvetlenül következik az eredmény</li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Oszd-meg-és-uralkodj (D&C)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li>Példa: <span class="highlight">csúcskeresés</span></li>
                    <li>Lépések: <span class="highlight">felosztás - uralkodás - összevonás</span></li>
                    <li>A problémát <span class="highlight">több diszjunkt, hasonló részre</span> osztjuk</li>
                    <li>A részeket <span class="highlight">rekurzívan megoldjuk</span></li>
                    <li>A részeredményeket <span class="highlight">összevonjuk</span> az eredeti probléma megoldásává</li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Dinamikus programozás (DP)</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li>Példa: <span class="highlight">pénzváltás probléma</span></li>
                    <li>Hasonló a D&C-hez, de itt <span class="highlight">azonos részproblémák is előfordulhatnak</span></li>
                    <li>A részproblémák megoldásait <span class="highlight">tároljuk és újrafelhasználjuk</span></li>
                    <li>Alternatíva a "nyers erő" megoldásokra</li>
                </ul>
            </div>
        </div>
        
    
        <div class="algorithm">
            <h2>Rendező algoritmusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li><span class="key-point">Beszúró rendezés:</span>
                        <ul>
                            <li>Végigiterál a tömbön a <span class="highlight">második elemtől</span> kezdve</li>
                            <li>Az aktuális elemet a <span class="highlight">megfelelő helyre beszúrja</span> a már rendezett részbe</li>
                            <li>Időigény: <span class="highlight">O(n^2)</span></li>
                        </ul>
                    </li>
                    <li><span class="key-point">Összefésülő rendezés:</span>
                        <ul>
                            <li><span class="highlight">Rekurzívan felezi</span> az inputot</li>
                            <li>A kapott részeket rendezi, majd <span class="highlight">összefésüli</span></li>
                            <li>Időigény: <span class="highlight">Θ(n log n)</span></li>
                        </ul>
                    </li>
                    <li><span class="key-point">Kupacrendezés:</span>
                        <ul>
                            <li><span class="highlight">Kupaccal</span> (bináris fa) reprezentálja a bemeneti tömböt</li>
                            <li><span class="highlight">Maximum kupacot</span> képez, majd a gyökérelemet kivéve rendezi a tömböt</li>
                            <li>Időigény: átlagosan <span class="highlight">O(n log n)</span>, legrosszabb esetben <span class="highlight">O(n^2)</span></li>
                        </ul>
                    </li>
                    <li><span class="key-point">Gyorsrendezés:</span>
                        <ul>
                            <li><span class="highlight">Oszd-meg-és-uralkodj</span> elven alapul</li>
                            <li><span class="highlight">Particionálja</span> a tömböt egy kulcselem körül</li>
                            <li><span class="highlight">Rekurzívan rendezi</span> a részeket</li>
                            <li>Időigény: átlagosan <span class="highlight">O(n log n)</span>, legrosszabb esetben <span class="highlight">O(n^2)</span></li>
                        </ul>
                    </li>
                    <li><span class="key-point">Leszámláló rendezés:</span>
                        <ul>
                            <li><span class="highlight">K-féle értéket</span> tartalmazó tömbökre alkalmazható</li>
                            <li><span class="highlight">Megszámolja</span> az értékek előfordulásait</li>
                            <li>A számlálók alapján <span class="highlight">helyezi el</span> az elemeket</li>
                            <li>Időigény: <span class="highlight">O(n + k)</span>, ahol k a különböző értékek száma</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        
        <div class="algorithm">
            <h2>Gráfalgoritmusok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <ul>
                    <li><span class="key-point">Szélességi keresés (BFS):</span>
                        <ul>
                            <li><span class="highlight">Rétegenként</span> járja be a gráfot</li>
                            <li><span class="highlight">Fehér, szürke, fekete</span> színezést használ</li>
                            <li><span class="highlight">Szélességi fát</span> eredményez</li>
                            <li>Időigény: <span class="highlight">O(V + E)</span></li>
                        </ul>
                    </li>
                    <li><span class="key-point">Mélységi keresés (DFS):</span>
                        <ul>
                            <li>A gráf ágait a <span class="highlight">lehető legmélyebbre</span> követi</li>
                            <li><span class="highlight">Mélységi feszítőerdőt</span> eredményez</li>
                            <li><span class="highlight">Faél, visszaél, előreél, keresztél</span> típusokat azonosít</li>
                            <li>Időigény: <span class="highlight">O(V + E)</span></li>
                        </ul>
                    </li>
                    <li><span class="key-point">Minimális feszítőfák:</span>
                        <ul>
                            <li>Kruskal algoritmus:
                                <ul>
                                    <li><span class="highlight">Minimális fák erdejét</span> tárolja</li>
                                    <li>Mindig a <span class="highlight">legkisebb, két fát összekötő élt</span> választja</li>
                                    <li>Időigény: <span class="highlight">O(E log E)</span></li>
                                </ul>
                            </li>
                            <li>Prim algoritmus:
                                <ul>
                                    <li><span class="highlight">Egyetlen fát</span> növeszt</li>
                                    <li>Minden lépésben a <span class="highlight">legolcsóbb élen</span> keresztül köt be új csúcsot</li>
                                    <li>Időigény: <span class="highlight">O(E log V)</span></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><span class="key-point">Legrövidebb utak:</span>
                        <ul>
                            <li>Dijkstra algoritmus:
                                <ul>
                                    <li>Mindig a <span class="highlight">legrövidebb úttal bíró csúcsot</span> választja</li>
                                    <li><span class="highlight">Nem működik negatív élsúlyok</span> esetén</li>
                                    <li>Időigény: <span class="highlight">O(E log V)</span></li>
                                </ul>
                            </li>
                            <li>Bellman-Ford algoritmus:
                                <ul>
                                    <li>Működik <span class="highlight">negatív élsúlyok</span> esetén is</li>
                                    <li>Észleli a <span class="highlight">negatív köröket</span></li>
                                    <li><span class="highlight">V-1 iterációban</span> próbál minden élen javítani</li>
                                    <li>Időigény: <span class="highlight">O(VE)</span></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <script src="../assets/js/tetel.js"></script>
</body>
</html>