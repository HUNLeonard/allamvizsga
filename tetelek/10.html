<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tétel 10 - Operációkutatás I.</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="../assets/css/tetel.css">
    <script defer data-domain="allamvizsga.netlify.app" src="https://plausible.io/js/script.js"></script>
</head>
<body class="dark-mode">
    <i class="fas fa-arrow-left back-button" id="backButton"></i>
    <i class="fas fa-adjust theme-toggle" id="themeToggle"></i>

    <h1>Operációkutatás I - 10. tétel</h1>
    <p class="desc"><em>
        <span class="highlight">LP alapfeladat, példa, szimplex algoritmus, az LP geometriája, </span><br>
        generálóelem választási szabályok, kétfázisú szimplex módszer, <br>
        <span class="highlight">speciális esetek</span><br>
        (ciklizáció-degeneráció, nem korlátos feladat, nincs lehetséges megoldás)
    </em></p>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>1. LP alapfeladat, példa, szimplex algoritmus</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Lineáris programozás alapfeladata</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=Fiy7daQG_Lo&list=PLDeiJeeT0bkgHr44CTt5cxmsKwR1-aB0u&index=1" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube videó a témáról 1
                </a>
                <a href="https://www.youtube.com/watch?v=0rZFAHWIXws&list=PLDeiJeeT0bkgHr44CTt5cxmsKwR1-aB0u&index=2" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube videó a témáról 2
                </a>
                <a href="https://www.youtube.com/watch?v=0rZFAHWIXws&list=PLDeiJeeT0bkgHr44CTt5cxmsKwR1-aB0u&index=3" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube videó a témáról 3
                </a>
                <p><span class="key-point">Mi az LP alapfeladat?</span> A lineáris programozás (LP) alapfeladata egy <span class="highlight">optimalizálási probléma</span>, ahol egy <span class="highlight">lineáris célfüggvény</span> szélsőértékét (maximumát vagy minimumát) keressük, miközben a változóink <span class="highlight">lineáris egyenlőtlenségekkel megadott feltételeknek</span> kell megfeleljenek.</p>


                <p><span class="key-point">Miért lineáris?</span> Mert mind a célfüggvény, mind a feltételek <span class="highlight">elsőfokú kifejezések</span> a változókban. Például: 2x + 3y lineáris, de x^2 vagy xy már nem.</p>

                <div class="step">
                    <p><span class="key-point">Standard alak:</span></p>
                    <img src="../assets/images/lp_alapfeladat.webp" alt="LP alapfeladat felírása" class="graph-image">
                </div>
                <p><span class="key-point">Képen látható:</span> (célfüggvény) | (feltételek) ... | (nem-negativitási feltételek)</p>
                <p><span class="key-point">Miért fontos a nem-negativitási feltétel?</span> A <span class="highlight">nem-negativitási feltétel</span> (x₁, ..., xₙ ≥ 0) mindig része az LP feladatnak, mert a legtöbb valós probléma esetén a <span class="highlight">negatív értékeknek nincs értelme</span> (pl. negatív mennyiségű termék gyártása).</p>
                <p><span class="key-point">Mi a lehetséges megoldás?</span> Egy <span class="highlight">lehetséges megoldás</span> olyan p = (p₁, ..., pₙ) ∈ ℝⁿ vektor, amely <span class="highlight">kielégíti a feladat összes feltételét</span>. A lehetséges megoldások halmaza az összes ilyen vektor összessége.</p>
                <p><span class="key-point">Mi az optimális megoldás?</span> Az <span class="highlight">optimális megoldás</span> az a lehetséges megoldás, ahol a célfüggvény felveszi a <span class="highlight">maximumát vagy minimumát</span>, attól függően, hogy mi a feladat célja.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Példa - Termékgyártási probléma</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <div class="step">
                    <p><span class="key-point">Példa: Termékgyártási probléma</span></p>
                    <p>Egy gyár <span class="highlight">katonákat és vonatokat</span> gyárt. A céljuk a <span class="highlight">profit maximalizálása</span>.</p>
                    <ul>
                        <li>Egy katona 3$-ba kerül és 1$-ért adják el</li>
                        <li>Egy vonat 2$-ba kerül és 1$-ért adják el</li>
                        <li>Összesen 80 egységnyi alapanyag áll rendelkezésre</li>
                        <li>A gyártási kapacitás 100 egység</li>
                        <li>Legalább 40 katonát kell gyártani</li>
                    </ul>
                </div>
                <div class="step">
                    <p><span class="key-point">Hogyan írjuk fel az LP feladatot?</span></p>
                    <img src="../assets/images/mix.bmp" alt="mix" class="graph-image">
                    <p><span class="key-point">Képen látható:</span> (célfüggvény: profit maximalizálása) |  <span class="highlight">(alapanyag korlát)</span> | (gyártási kapacitás) | <span class="highlight">(minimum katona követelmény)</span> |  (nem-negativitási feltétel)</p>
                    <p>Ahol x₁ a katonák száma, x₂ a vonatok száma.</p>
                </div>
                <p><span class="key-point">Mi a megoldás?</span> A feladat <span class="highlight">optimális megoldása</span>: x* = (20, 60), azaz <span class="highlight">20 katona és 60 vonat gyártása</span>. Az <span class="highlight">optimum értéke</span>: z* = 180, vagyis 180$ profit érhető el.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>2. Szimplex algoritmus</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Szimplex algoritmus alapjai</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a szimplex algoritmus?</span> A szimplex algoritmus egy <span class="highlight">hatékony módszer</span> lineáris programozási feladatok megoldására. Az algoritmus <span class="highlight">iteratív módon</span> javítja a megoldást, amíg el nem éri az optimumot vagy be nem bizonyosodik, hogy nincs optimális megoldás.</p>
                
                <div class="step">
                    <p><span class="key-point">Hogyan működik a szimplex algoritmus?</span></p>
                    <ol>
                        <li><span class="highlight">Kezdeti bázismegoldás</span> meghatározása</li>
                        <li>A megoldás <span class="highlight">javítása lépésenként</span></li>
                        <li><span class="highlight">Optimális megoldás</span> elérése vagy a feladat <span class="highlight">megoldhatatlanságának</span> bizonyítása</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Mi a szótár alak?</span> A szimplex algoritmus az úgynevezett <span class="highlight">szótár alakú feladattal</span> dolgozik. Ebben a formában az <span class="highlight">egyenlőtlenségeket egyenlőségekké alakítjuk</span> ún. eltérésváltozók bevezetésével.</p>
                
                <div class="step">
                    <p><span class="key-point">Példa szótár alakra:</span></p>
                    <img src="../assets/images/szotar_alak.jpg" alt="szotar alak" class="graph-image">
                </div>
                <ul>
                    <li><span class="highlight" style="color: #b51eff;">Bázisváltozók: </span>A szótár alakú feladat <span class="highlight">bal oldalán szereplő változók</span>. Értékük az egyenletek jobb oldalán álló konstans.</li>
                    <li><span class="highlight"  style="color: rgb(255, 187, 0);">Nembázis változók:</span> A szótár alakú feladat <span class="highlight">jobb oldalán álló változók</span>. Értékük 0!</li>
                </ul>
            </div>
        </div>
    
        <div class="algorithm">
            <h2>Szimplex algoritmus lépései</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Hogyan működik a szimplex algoritmus?</span> A szimplex algoritmus <span class="highlight">iteratív módon</span> javítja a megoldást a következő lépéseken keresztül:</p>
                
                <div class="step">
                    <p><span class="key-point">Algoritmus lépései:</span></p>
                    <ol>
                        <li><span class="highlight">Input:</span> A szótár alakú feladat.</li>
                        <li><span class="highlight">Pivot lépések:</span> Amíg van pozitív együtthatójú célfüggvény változónk:
                            <ol>
                                <li><span class="highlight">Generáló elem választása:</span>
                                    <ol>
                                        <li><span class="highlight">Oszlop választás:</span> Pozitív célfüggvény együttható közül a legnagyobb. Ha több azonos, a kisebb indexűt.</li>
                                        <li><span class="highlight">Sor választás:</span> Hányados szabály alapján. Ha van negatív együtthatójú változó, vége az algoritmusnak.</li>
                                    </ol>
                                </li>
                                <li><span class="highlight">Belépő változó kifejezése és behelyettesítése</span></li>
                            </ol>
                        </li>
                        <li><span class="highlight">Output:</span> Megoldás (nincs megoldás / nem korlátos a feladat / az optimum értéke).</li>
                    </ol>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Fontos fogalmak:</span></p>
                    <ul>
                        <li><span class="highlight">Belépőváltozó:</span> Az a nem bázis változó, ami a következő szótárban már bázisváltozó.</li>
                        <li><span class="highlight">Kilépőváltozó:</span> Az a bázisváltozó, ami a következő szótárban már nem bázis változó.</li>
                        <li><span class="highlight">Pivot szabály:</span> Szabály, amely meghatározza a belépő- és kilépőváltozókat.</li>
                        <li><span class="highlight">Degenerált iterációs lépés:</span> Olyan szimplex iteráció, amelyben nem változik a bázismegoldás.</li>
                    </ul>
                </div>
                
                <p><span class="key-point">Miért hatékony ez az algoritmus?</span> A szimplex algoritmus <span class="highlight">garantáltan véges számú lépésben</span> megtalálja az optimális megoldást vagy bebizonyítja, hogy nincs megoldás. Bár <span class="highlight">elméleti legrosszabb esetben</span> exponenciális futásidejű lehet, a <span class="highlight">gyakorlatban rendkívül hatékony</span>.</p>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>3. Az LP Geometriája</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Az LP Geometriája</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Miért fontos az LP geometriai értelmezése?</span> Az LP geometriai értelmezése <span class="highlight">segít vizualizálni</span> a problémát és annak megoldását,<span class="highlight">mélyebb megértést biztosít</span> az algoritmus működéséről, és <span class="highlight">intuitív betekintést nyújt</span> az optimalizálási folyamatba.</p>

                <div class="step">
                    <p><span class="key-point">Alapvető geometriai fogalmak:</span></p>
                    <ul>
                        <li><span class="highlight">n-dimenziós tér (R^n):</span> Olyan tér, ahol minden pontot n szám határoz meg.</li>
                        <li><span class="highlight">Euklideszi tér (E^n):</span> Speciális n-dimenziós tér, ahol értelmezett a távolság és a szög.</li>
                        <li><span class="highlight">Pont:</span> n hosszúságú koordináta-vektor.</li>
                        <li><span class="highlight">Lehetséges megoldások:</span> Pontok az n-dimenziós Euklideszi térben.</li>
                        <li><span class="highlight">Lineáris feltételek:</span> Síkok vagy falak a térben / Zárt félterek és síkok</li>
                        <li><span class="highlight">Lehetséges megoldások halmaza:</span> Zárt félterek és síkok metszete, egy konvex poliéder.</li>
                        <li><span class="highlight">Feltételek:</span> A poliéder lapjai.</li>
                        <li><span class="highlight">Bázismegoldások:</span> A poliéder csúcsai.</li>
                    </ul>
                </div>
                
                <img src="../assets/images/n_dimenzios_ter.webp" alt="n-dimenziós tér" class="graph-image">
            </div>
        </div>

        <div class="algorithm">
            <h2>Szimplex algoritmus geometriai interpretációja</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Hogyan értelmezhető geometriailag a szimplex algoritmus?</span> A szimplex algoritmus <span class="highlight">a lehetséges megoldások poliéderének csúcsain halad végig</span>, minden lépésben javítva a célfüggvény értékét.</p>

                <div class="step">
                    <p><span class="key-point">Példa a szimplex algoritmus lépéseire:</span></p>
                    <img src="../assets/images/szimplex_algoritmus.webp" alt="Szimplex algoritmus" class="graph-image">
                    <p>A klasszikus pivot stratégiával végrehajtva a szimplex algoritmust, a következő bázismegoldások adódnak:</p>
                    <pre>
[0 0 0| 4 5] → [0 0 5| 4 0] → [2 0 5| 0 0] → [0 4 5| 0 0]</pre>
                </div>

                <p><span class="key-point">Mit jelentenek ezek a lépések geometriailag?</span> Ezek a bázismegoldások rendre a következő <span class="highlight">poliéder csúcsoknak</span> felelnek meg:</p>
                <pre>
[0 0 0] → [0 0 5] → [2 0 5] → [0 4 5]</pre>

                <p><span class="key-point">Mi a pivot lépés geometriai jelentése?</span> Egy pivot lépés az <span class="highlight">aktuális bázismegoldásból induló valamelyik él mentén történő ellépés</span> egy "szomszédos" bázismegoldásba (azaz csúcsba).</p>

                <p><span class="key-point">Miért hatékony ez a módszer?</span> A szimplex algoritmus hatékonysága abból ered, hogy <span class="highlight">csak a csúcspontokat vizsgálja</span>, amelyek a lehetséges optimális megoldások helyei.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Ciklizáció geometriai értelmezése</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Hogyan jelenik meg a ciklizáció geometriailag?</span> A ciklizáció során az algoritmus <span class="highlight">ugyanazon csúcspontok között "ingázik"</span>, anélkül hogy javítaná a célfüggvény értékét.</p>
                
                <p><span class="key-point">Alapfogalmak:</span></p>
                <ul>
                    <li><span class="key-point"><ruby>Degeneráció:<rp>(</rp><rt style="font-size: 65%; color:#abb0ff;">Mi okozza a ciklizációt geometriailag?</rt><rp>)</rp></ruby></span> 
                        A ciklizáció gyakran <span class="highlight">degenerációval</span> jár együtt, ami azt jelenti, hogy egy n-dimenziós csúcspont <span class="highlight">legalább n + 1 síkra esik</span>.</li>
                    <li><span class="key-point"><ruby>Degenerált iterációs lépés:<rp>(</rp><rt style="font-size: 65%; color:#abb0ff;">Mit jelent a degeneráció geometriailag?</rt><rp>)</rp></ruby></span> 
                        Degenerált iterációs lépéskor a <span class="highlight">"csúcsban maradunk"</span>, azaz nem mozdulunk el a poliéder egy másik csúcspontjába.</li>
                    <li><span class="key-point"><ruby>Ciklizáció elkerülhető:<rp>(</rp><rt style="font-size: 65%; color:#abb0ff;">Hogyan kerülhető el a ciklizáció?</rt><rp>)</rp></ruby></span> 
                        A ciklizáció elkerülésére használható például a <span class="highlight">perturbáció módszere</span>, amely "szétválasztja" a degenerációt okozó síkokat egymástól, így biztosítva, hogy az algoritmus ne ragadjon be egy csúcspontba.</li>
                </ul>


                <div class="step">
                    <p><span class="key-point">Példa ciklizációra:</span></p>
                    <p><span class="highlight">A klasszikus pivot stratégiával</span> a következő bázismegoldások adódhatnak:</p>
                    <pre>[0 0 0| 4 4] → [0 0 1| 0 0] → [0 0 1| 0 0] → [4 4 0| 0 0]</pre>
                    <p>Ezek a <span class="highlight">bázismegoldások rendre</span> a következő <span class="highlight">poliéder csúcsoknak</span> felelnek meg:</p>
                    <pre>[0 0 0] → [0 0 1] → [0 0 1] → [4 4 0]</pre>
                </div>
                
                <img src="../assets/images/ciklizacio_geometria.webp" alt="Ciklizáció és geometria" class="graph-image">
            </div>
        </div>

        <div class="algorithm">
            <h2>Ciklizáció Perturbáció módszere</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a perturbáció módszere?</span> A perturbáció módszere egy <span class="highlight">technika a ciklizáció elkerülésére</span>, amely a degenerált megoldások "szétválasztásával" működik.</p>

                <div class="step">
                    <p><span class="key-point">Hogyan működik a perturbáció?</span> A módszer lényege, hogy <span class="highlight">kis változtatásokat</span> (perturbációkat) alkalmazunk a feladat feltételeiben:</p>
                    <img src="../assets/images/perturbacio.bmp" alt="Szimplex algoritmus" class="graph-image">
                    <p>Ahol ε₁ és ε₂ nagyon kis pozitív számok.</p>
                </div>
                <p><span class="key-point">Mi a perturbáció hatása?</span> A perturbáció <span class="highlight">megszünteti a degenerációt</span> azáltal, hogy <span class="highlight">szétválasztja a degenerációt okozó síkokat</span> egymástól.</p>

                <div class="step">
                    <p><span class="key-point">A perturbáció előnyei:</span></p>
                    <ul>
                        <li><span class="highlight">Elkerüli a ciklizációt</span> a degeneráció megszüntetésével</li>
                        <li><span class="highlight">Javítja az algoritmus stabilitását</span></li>
                        <li>Lehetővé teszi az algoritmus <span class="highlight">garantált véges lépésben történő befejezését</span></li>
                    </ul>
                </div>

                <p><span class="key-point">Mire kell figyelni?</span> A perturbáció alkalmazásakor fontos, hogy a bevezetett változtatások <span class="highlight">elég kicsik legyenek</span> ahhoz, hogy ne befolyásolják jelentősen az eredeti feladat optimális megoldását.</p>

                <p><span class="key-point">Geometriai értelmezés:</span> Geometriailag a perturbáció <span class="highlight">kissé elmozdítja a feltételi egyeneseket vagy síkokat</span>, így a degenerált csúcspontok "szétválnak", és az algoritmus képes lesz továbblépni.</p>
                
                <img src="../assets/images/ciklizacio_perturbacio.webp" alt="Ciklizáció perturbáció" class="graph-image">
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>4. Generálóelem Választási Szabályok</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Generálóelem Választás alapjai</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <a href="https://www.youtube.com/watch?v=xPj6PGh2hZc&list=PLDeiJeeT0bkgHr44CTt5cxmsKwR1-aB0u&index=4" class="algorithm-link" target="_blank">
                    <i class="fas fa-video"></i> Youtube videó a témáról
                </a>
                <p><span class="key-point">Alapelv:</span> A generálóelem választás a <span class="highlight">szimplex algoritmus kulcsfontosságú lépése</span>, amely meghatározza, hogyan haladunk egyik bázismegoldásról a másikra az optimum keresése során.</p>
                
                <div class="step">
                    <p><span class="key-point">Előkészítő lépések:</span></p>
                    <ol>
                        <li><span class="highlight">Feladat felírása:</span> Korlátozások és célfüggvény megadása</li>
                        <li><span class="highlight">Mesterséges változók bevezetése:</span> Minden korlátozáshoz egy új változó hozzáadása</li>
                        <li><span class="highlight">Szótár alak létrehozása:</span> A feladat átírása úgy, hogy a mesterséges változókat kifejezzük</li>
                        <li><span class="highlight">Bázismegoldás leolvasása:</span> A kifejezett változók és a hozzájuk tartozó konstansok értékének meghatározása</li>
                        <li><span class="highlight">Optimalitás ellenőrzése:</span> Ha a célfüggvényben nincs pozitív együtthatós változó, a megoldás optimális</li>
                        <li><span class="highlight">Generálóelem választása:</span> Ha nem optimális, új elem választása a további javításhoz</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Optimális megoldás:</span> Egy bázismegoldás akkor optimális, ha a <span class="highlight">célfüggvényben már nincs pozitív együtthatós változó</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Hányadosteszt:</span></p>
                    <ol>
                        <li>Vesszük azokat a korlátokat, ahol a <span class="highlight">belépő változó negatívan szerepel</span></li>
                        <li><span class="highlight">Konstans értéket elosztjuk</span> a belépő változó szorzójának abszolút értékével</li>
                        <li><span class="highlight">Legkisebb értéket</span> adó sor lesz a kilépő változó</li>
                    </ol>
                </div>
                
                <p><span class="key-point">Miért fontos a hányadosteszt?</span> A hányadosteszt biztosítja, hogy a <span class="highlight">new bázismegoldás is megengedett legyen</span>, azaz ne sértse meg a feltételeket.</p>
                
                <img src="../assets/images/generaloelem_valasztasi_szabalyok.bmp" alt="Generálóelem választási szabályok példa" class="graph-image">
            </div>
        </div>
        <div class="algorithm">
            <h2>Generálóelem választási szabályok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Milyen szabályok léteznek?</span> Több szabály létezik a generálóelem kiválasztására, mindegyiknek megvan a maga előnye és alkalmazási területe.</p>

                <div class="step">
                    <p><span class="key-point">1. Klasszikus szabály:</span></p>
                    <ul>
                        <li><span class="highlight">Belépő változó:</span> A "legpozitívabb" konstansú változó a célfüggvényben</li>
                        <li><span class="highlight">Kilépő változó:</span> Hányadosteszt alapján, ütközés esetén a legkisebb indexű egyenlet bázisváltozója</li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">2. Bland szabály:</span></p>
                    <ul>
                        <li><span class="highlight">Belépő változó:</span> A legkisebb indexű lehetséges belépő változó</li>
                        <li><span class="highlight">Kilépő változó:</span> Hányadosteszt alapján, ütközés esetén a legkisebb indexű egyenlet bázisváltozója</li>
                        <li><span class="highlight">Előnye:</span> Garantáltan véges számú lépésben véget ér az algoritmus. <span class="highlight">Ciklizáció elkerülésére</span> fejlesztették ki.</li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">3. Legnagyobb növekmény szabály:</span></p>
                    <ul>
                        <li><span class="highlight">Cél:</span> A célfüggvény értékét legjobban növelő változó kiválasztása</li>
                        <li><span class="highlight">Módszer:</span> Hányadosteszt minden lehetséges belépő változóra, a legnagyobb növekményt adó választása</li>
                        <li><span class="highlight">Előnye:</span> Gyorsabb konvergencia az optimum felé</li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">Miben különbözik a Bland-szabály és a legnagyobb növekmény szabály?</span></p>
                    <ul>
                        <li><span class="highlight">Bland-szabály:</span> Garantálja a véges futást, de lehet lassabb</li>
                        <li><span class="highlight">Legnagyobb növekmény:</span> Általában gyorsabb konvergencia, de nem garantál véges futást</li>
                    </ul>
                </div>
            </div>
        </div>

    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>5. Kétfázisú Szimplex Módszer</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Kétfázisú Szimplex Módszer</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mikor használjuk a kétfázisú szimplex módszert?</span> Kétfázisú szimplex módszert akkor alkalmazunk, amikor a <span class="highlight">szótár eredeti alakja nem lehetséges</span>, azaz valamelyik korlát jobb oldalán negatív szám szerepel.</p>
                
                <div class="step">
                    <p><span class="key-point">A módszer lépései:</span></p>
                    <ol>
                        <li><span class="highlight">Szótár alak felírása</span> Felírjuk a megszokott szótár alakot a mesterséges változókkal.</li>
                        <li><span class="highlight">x₀ változó bevezetése:</span> Minden egyenlethez felveszünk egy +x₀ változót.</li>
                        <li><span class="highlight">Segédfeladat létrehozása:</span> A Z(x) maximalizálási feladathoz felvesszük a W(x) minimalizálási segédfeladatot, amit úgy kapunk, hogy a Z(x)-ben található előjeleket megváltoztatjuk.</li>
                        <li><span class="highlight">Generálóelem választás:</span> Addig választunk generálóelemet a kiegészített feladatban, ameddig a segédfüggvényre nem tudjuk kihozni a 0 értéket.</li>
                        <li><span class="highlight">Szótár átalakítása:</span> Ha megvan a 0 érték, akkor a legnegatívabb korlátból kifejezzük x₀ értékét, behelyettesítjük a többi korlátba az ő értékét.</li>
                    </ol>
                </div>
                <p><span class="key-point">Mi a módszer célja?</span> A módszer célja, hogy <span class="highlight">olyan szótár alakot kapjunk</span>, amire már <span class="highlight">tudjuk alkalmazni a szimplex algoritmust</span>.</p>
                <p><span class="key-point">Miért hatékony ez a módszer?</span> A kétfázisú módszer lehetővé teszi, hogy <span class="highlight">olyan LP feladatokat is megoldjunk</span>, amelyeknél az egyszerű szimplex módszer nem alkalmazható közvetlenül. Ez <span class="highlight">növeli az LP alkalmazhatóságának körét</span> és rugalmasságát.</p>
                <p><span class="key-point">Mikor van megoldása az eredeti feladatnak?</span> A standard feladatnak akkor, és csak akkor van lehetséges megoldása, ha a <span class="highlight">hozzá felírt segédfeladat optimuma 0</span>. Ha ez nem elérhető, vagy nincs megoldása, akkor a standard feladat sem megoldható.</p>

                <div class="step">
                    <p><span class="key-point">Kétfázisú algoritmus:</span></p>
                    <p><span class="key-point">1. fázis:</span></p>
                    <ul>
                        <li>Ha a <span class="highlight">standard</span> feladat szótárának <span class="highlight">bázismegoldása lehetséges</span> -> <span class="highlight">2. fázis</span></li>
                        <li><span class="highlight">Ha nem</span>, társítjuk a segéfeladatot <span class="highlight">(készítsük el átalakított szótárát)</span></li>
                        <li><span class="highlight">Segédfeladat megoldása átalakított szótárból</span></li>
                        <li>Ha <span class="highlight">optimum < 0</span>, nincs 2. fázis, <span class="highlight">nincs megoldás</span></li>
                        <li>Ha <span class="highlight">optimum = 0</span>, <span class="highlight">készítünk</span> egy lehetséges <span class="highlight">bázismegoldású szótárat</span></li>
                    </ul>
                    <p><span class="key-point">2. fázis:</span></p>
                    <ul>
                        <li>Szimplex algoritmus végrehajtása az első fázisból kapott szótárból</li>
                    </ul>
                </div>
                <p><span class="key-point">Mi történik az első fázisban?</span> Az első fázisban <span class="highlight">egy segédfeladatot oldunk meg</span>, amelynek célja egy <span class="highlight">lehetséges kezdeti bázismegoldás</span> megtalálása az eredeti feladathoz.</p>
                
                <p><span class="key-point">Mi történik a második fázisban?</span> A második fázisban az <span class="highlight">eredeti célfüggvénnyel dolgozunk</span>, és a szimplex algoritmus segítségével megkeressük az optimális megoldást.</p>
                
            </div>
        </div>

        <div class="algorithm">
            <h2>Kétfázisú Szimplex Módszer - Példa</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <div class="step">
                    <p><span class="key-point">Eredeti feladat:</span></p>
                    <pre>
Max  z = x1  -  x2  +  x3 
     2x1 -  x2  +  x3 ≤ 4
     2x1 -  3x2 +  x3 ≤ <span style="color: #2c9cff">-5</span>
    -x1  +  x2  - 2x3 ≤ <span style="color: #2c9cff">-1</span>
     x1,    x2,    x3 ≥ 0</pre>
                </div>
                
                <div class="step">
                    <p><span class="key-point">1. Lépés: Induló szótár felírása</span></p>
                    <pre>
x4 = 4 - 2x1 + x2 - 2x3
x5 = <span style="color: #2c9cff">-5</span> - 2x1 + 3x2 - x3
x6 = <span style="color: #2c9cff">-1</span> + x1 - x2 + 2x3
---------------------
z =       x1 - x2 + x3</pre>
                    <p>Ez <span class="highlight">nem lehetséges</span> induló szótár, mert x5, x6 < 0 a bázismegoldásban.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">2. Lépés: Segédfeladat felírása</span></p>
                    <p>Új mesterséges változó (x0) bevezetése:</p>
                    <pre>
Max  w =                  -x0
     2x1 -  x2  +  x3 <span style="color: #2c9cff">-x0</span> ≤ 4
     2x1 -  3x2 +  x3 <span style="color: #2c9cff">-x0</span> ≤ -5
    -x1  +  x2  - 2x3 <span style="color: #2c9cff">-x0</span> ≤ -1
     x1,    x2,    x3  x0 ≥ 0</pre>
                </div>
                
                <div class="step">
                    <p><span class="key-point">3. Lépés: x0 kifejezése a legnegatívabb jobboldalú egyenletből</span></p>
                    <pre>
x0 = 5 + 2x1 - 3x2 + x3  + x5
x4 = 9       - 2x2       + x5
x6 = 4 + 3x1 - 4x2 + 3x3 + x5
---------------------
w =  -5 -2x1 + 3x2 - x3 - x5</pre>
                    <p>Ez már egy <span class="highlight">lehetséges induló szótár</span>.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">4. Lépés: Szimplex algoritmus alkalmazása a segédfeladatra</span></p>
                    <p>Ezt a lépést addig ismételjük, amíg w = 0 nem lesz.</p>
                </div>
                
                <div class="step">
                    <p><span class="key-point">5. Lépés: Eredeti feladat megoldása</span></p>
                    <p>Ha a segédfeladat optimuma 0, akkor az utolsó szótárból felírhatjuk az eredeti feladat lehetséges megoldását:</p>
                    <ul>
                        <li>Elhagyjuk x0-t</li>
                        <li>Visszaírjuk az eredeti célfüggvényt</li>
                        <li>Alkalmazzuk a szimplex algoritmust erre a szótárra</li>
                    </ul>
                </div>
                
                <div class="step">
                    <p><span class="key-point">Végső megoldás:</span></p>
                    <pre>
x2 = 5.5 - 0.5x4 + 0.5x3
x1 = 0.5 - 0.5x4 - 0.5x3
-----------------------
z = 6.5 - 1.5x4 - 0.5x3</pre>
                    <p>Ez a <span class="highlight">végső optimális megoldás</span> az eredeti feladatra.</p>
                </div>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>6. Speciális esetek</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Ciklizáció-degeneráció</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mi a ciklizáció?</span> A ciklizáció az a jelenség, amikor a szimplex algoritmus <span class="highlight">ugyanazokat a bázismegoldásokat ismétli végtelenül</span>, anélkül hogy elérné az optimális megoldást.</p>

                <p><span class="key-point">Mi a degeneráció?</span> Egy bázismegoldás <span class="highlight">degeneráltnak</span> nevezhető, ha a változói közül <span class="highlight">legalább az egyik értéke 0</span>.</p>
                
                <div class="step">
                    <p><span class="key-point">Degenerált bázismegoldás:</span> Egy bázismegoldás <span class="highlight">degeneráltnak</span> nevezhető, ha a változói közül <span class="highlight">legalább az egyik értéke 0</span>.</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Degenerált iterációs lépés:</span> Olyan szimplex iteráció, amelyben <span class="highlight">nem változik a bázismegoldás értéke</span>.</p>
                </div>

                <p><span class="key-point">Mi az összefüggés a ciklizáció és a degeneráció között?</span> A degeneráció gyakran <span class="highlight">vezethet ciklizációhoz</span>, mivel a degenerált megoldások lehetővé teszik, hogy az algoritmus "egy helyben topogjon".</p>

                <p><span class="key-point">Hogyan hat ez az algoritmusra?</span> A ciklizáció azt eredményezi, hogy az algoritmus <span class="highlight">ugyanazokat a lépéseket ismétli</span> végtelenül, anélkül hogy elérné az optimális megoldást.</p>

                <div class="step">
                    <p><span class="key-point">Példa ciklizációra:</span></p>
                    <pre>
1. iteráció:
x₅ = -½x₁ + 11/2x₂ + 5/2x₃ - 9x₄
x₆ = -½x₁ + 3/2x₂ + ½x₃ - x₄
x₇ = 1 - x₁
z = 10x₁ - 57x₂ - 8x₃ - 24x₄

...

7. iteráció:
x₅ = -½x₁ + 11/2x₂ + 5/2x₃ - 9x₄
x₆ = -½x₁ + 3/2x₂ + ½x₃ - x₄
x₇ = 1 - x₁
z = 10x₁ - 57x₂ - 8x₃ - 24x₄
                    </pre>
                    <p>Látható, hogy a 7. iteráció után <span class="highlight">visszakaptuk a kiindulási feladatot</span>.</p>
                </div>

                <p><span class="key-point">Hogyan kerülhető el a ciklizáció?</span> A ciklizáció elkerülhető <span class="highlight">megfelelő pivot szabály alkalmazásával</span>, például a Bland-szabály használatával, amely garantálja, hogy az algoritmus véges számú lépésben véget ér.</p>
            </div>
        </div>

        <div class="algorithm">
            <h2>Nem korlátos feladat</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mikor nem korlátos egy feladat?</span> Ha a feladatnak <span class="highlight">nincs optimális megoldása</span>, mert a célfüggvény értéke tetszőlegesen nagy (maximalizálás esetén) vagy kicsi (minimalizálás esetén) lehet.</p>

                <div class="step">
                    <p><span class="key-point">Hogyan ismerjük fel?</span></p>
                    <ul>
                        <li>Ha van olyan <span class="highlight">nem bázisváltozó pozitív együtthatóval</span> a célfüggvényben</li>
                        <li>És <span class="highlight">nincs negatív együttható</span> ugyanennél a változónál a feltételekben</li>
                        <li>Akkor a feladat <span class="highlight">nem korlátos</span></li>
                    </ul>
                </div>

                <div class="step">
                    <p><span class="key-point">Példa nem korlátos feladatra:</span></p>
                    <pre>
x₃ = 5 + 2x₂ - ⅓x₄
x₁ = 3 + 3x₂ + ⅓x₄
max z = 21 + 25x₂ - 7/3x₄

II. iteráció:
A legpozitívabb együtthatójú változó: x₂
A legkisebb korlátot adó egyenlet: Nincs, mert mindkét
egyenletben x₂ együtthatója pozitív.
                    </pre>
                    <p>Ebben az esetben az egyenletrendszer nem korlátos.</p>

                    <p><span class="key-point">Mit jelent ez geometriailag?</span> Geometriailag ez azt jelenti, hogy a <span class="highlight">lehetséges megoldások halmaza "nyitott"</span> abban az irányban, amerre a célfüggvény növekszik.</p>
                    
                    <p><span class="key-point">Hogyan kezeljük?</span> Ha nem korlátos feladatot észlelünk, <span class="highlight">megállítjuk az algoritmust</span> és jelezzük, hogy a feladatnak nincs véges optimuma. Gyakran ez arra utal, hogy a <span class="highlight">probléma megfogalmazása hibás</span> vagy hiányos.</p>
                </div>
            </div>
        </div>

        <div class="algorithm">
            <h2>Nincs lehetséges megoldás</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <p><span class="key-point">Mit jelent, ha nincs lehetséges megoldás?</span> Ez azt jelenti, hogy <span class="highlight">nem létezik olyan megoldás</span>, amely az összes feltételt egyszerre kielégítené. Másképpen fogalmazva, a <span class="highlight">feltételrendszer ellentmondásos</span>.</p>
                <div class="step">
                    <p><span class="key-point">Hogyan derül ki, hogy nincs megoldás?</span></p>
                    <ul>
                        <li>A <span class="highlight">kétfázisú szimplex módszer első fázisában</span></li>
                        <li>Ha a <span class="highlight">segédfeladat optimuma nem 0</span></li>
                        <li>Vagy ha <span class="highlight">nem tudjuk eltávolítani az összes mesterséges változót</span> a bázisból</li>
                    </ul>
                </div>
                <p><span class="key-point">Mit tegyünk, ha nincs megoldás?</span> Ha kiderül, hogy a feladatnak nincs lehetséges megoldása, akkor:</p>
                <ul>
                    <li><span class="highlight">Ellenőrizzük a feltételrendszert</span> esetleges hibák vagy ellentmondások miatt</li>
                    <li><span class="highlight">Lazítsunk a feltételeken</span>, ha lehetséges</li>
                    <li><span class="highlight">Újrafogalmazzuk a problémát</span>, ha szükséges</li>
                </ul>

                <p><span class="key-point">Mi Tucker tétele?</span> Tucker tétele kimondja, hogy <span class="highlight">lineáris egyenlőtlenségek és egyenletek egy rendszere megoldhatatlan akkor és csak akkor, ha inkonzisztens</span>.</p>

                <div class="step">
                    <p><span class="key-point">Példa lehetséges megoldás nélküli feladatra:</span></p>
                    <pre>
Max z = x₁ - x₂ + x₃
2x₁ - x₂ + x₃ ≤ 4
2x₁ - 3x₂ + x₃ ≤ -5
-x₁ + x₂ - 2x₃ ≤ -1
x₁, x₂, x₃ ≥ 0
                    </pre>
                    <p>Ebben a példában a feltételek ellentmondanak egymásnak, így nincs lehetséges megoldás.</p>
                </div>
            </div>
        </div>
    </div>

    <div class="main-topic" onclick="toggleMainContent(this)">
        <h2>7. Összefoglalás és Gyakori Kérdések</h2>
    </div>
    <div class="main-content">
        <div class="algorithm">
            <h2>Összefoglaló kérdések és válaszok</h2>
            <p class="toggle-content">További részletek <i class="fas fa-chevron-down"></i></p>
            <div class="content">
                <div class="step">
                    <p><span class="key-point">Mi az LP feladat lényege?</span> Az LP feladat egy <span class="highlight">optimalizálási probléma</span>, ahol egy lineáris célfüggvény szélsőértékét keressük lineáris feltételek mellett.</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Miből áll az LP alapfeladat?</span> Az LP alapfeladat <span class="highlight">célfüggvényből, feltételekből és nem-negativitási kikötésekből</span> áll.</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Mi a szimplex algoritmus bemenete és kimenete?</span> A bemenete egy <span class="highlight">szótár alakú feladat</span>, a kimenete pedig vagy az <span class="highlight">optimális megoldás</span>, vagy jelzés, hogy <span class="highlight">nincs megoldás / nem korlátos a feladat</span>.</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Mi a kétfázisú szimplex módszer lényege?</span> A kétfázisú módszer először egy <span class="highlight">lehetséges kezdeti megoldást keres</span> (1. fázis), majd ebből kiindulva <span class="highlight">optimalizál</span> (2. fázis).</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Mi a különbség a degeneráció és a ciklizáció között?</span> A <span class="highlight">degeneráció</span> egy állapot, ahol egy bázisváltozó értéke 0, míg a <span class="highlight">ciklizáció</span> egy folyamat, ahol az algoritmus ugyanazokat a lépéseket ismétli végtelenül.</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Mikor mondjuk, hogy egy LP feladat nem korlátos?</span> Amikor a <span class="highlight">célfüggvény értéke tetszőlegesen nagy lehet</span> a feltételek megsértése nélkül.</p>
                </div>

                <div class="step">
                    <p><span class="key-point">Hogyan ismerjük fel, ha egy feladatnak nincs lehetséges megoldása?</span> Ha a <span class="highlight">kétfázisú szimplex első fázisában</span> nem tudunk 0 értéket elérni a segédfüggvénynél.</p>
                </div>
            </div>
        </div>
    </div>

    <script src="../assets/js/tetel.js"></script>
</body>
</html>